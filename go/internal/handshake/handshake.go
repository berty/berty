package handshake

import (
	crand "crypto/rand"

	"golang.org/x/crypto/nacl/box"

	"berty.tech/berty/v2/go/internal/cryptoutil"
	"berty.tech/berty/v2/go/pkg/errcode"

	ggio "github.com/gogo/protobuf/io"
	p2pcrypto "github.com/libp2p/go-libp2p-core/crypto"
)

// Handshake Sequence Diagram:
// ---------------------------
// Handshake vastely inspired by Scuttlebutt's Capability-based Handshake
// https://scuttlebot.io/more/protocols/shs.pdf
//
// - a, b are ephemeral key pairs generated by respectively Requester and
//   Responder. Ephemeral keys are used for one handshake only and then
//   discarded. They guarantee the freshness of the messages and avoid
//   replay attacks.
// - A, B are the Account IDs of respectively Requester and Responder.
// - a.b denotes a secret derived from the two keys a and b.
// - | is the concatenation operator.
// - box[a.b](content) denotes the encryption of content using Nacl box
//   with a.b as key.
// - sig[A](content) denotes the signature of content verified by A.
//
//
//		+-----------+                       +-----------+
//		| Requester |                       | Responder |
//		+-----------+                       +-----------+
//			  | ---------------------\            |
//			  |-| 1. Requester Hello |            |
//			  | |--------------------|            |
//			  |                                   |
//			  | a                                 |
//			  |---------------------------------->|
//			  |            ---------------------\ |
//			  |            | 2. Responder Hello |-|
//			  |            |--------------------| |
//			  |                                   |
//			  |                                 b |
//			  |<----------------------------------|
//			  | ----------------------------\     |
//			  |-| 3. Requester Authenticate |     |
//			  | |---------------------------|     |
//			  |                                   |
//			  | box[a.b|a.B](A,sig[A](a.b))       |
//			  |---------------------------------->|
//			  |           ----------------------\ |
//			  |           | 4. Responder Accept |-|
//			  |           |---------------------| |
//			  |                                   |
//			  |         box[a.b|A.B](sig[B](a.b)) |
//			  |<----------------------------------|
//			  | ---------------------------\      |
//			  |-| 5. Requester Acknowledge |      |
//			  | |--------------------------|      |
//			  |                                   |
//			  | ok                                |
//			  |---------------------------------->|
//			  |                                   |

// Constant nonces
var (
	nonceRequesterAuthenticate = [cryptoutil.NonceSize]byte{1}
	nonceResponderAccept       = [cryptoutil.NonceSize]byte{2}
)

// Common struct and methods
type handshakeContext struct {
	reader          ggio.Reader
	writer          ggio.Writer
	ownAccountID    p2pcrypto.PrivKey
	peerAccountID   p2pcrypto.PubKey
	ownEphemeral    *[cryptoutil.KeySize]byte
	peerEphemeral   *[cryptoutil.KeySize]byte
	sharedEphemeral *[cryptoutil.KeySize]byte
}

// Generates own Ephemeral key pair and send pub key to peer
func (hc *handshakeContext) generateOwnEphemeralAndSendPubKey() error {
	// Generate own Ephemeral key pair
	ownEphemeralPub, ownEphemeralPriv, err := box.GenerateKey(crand.Reader)
	if err != nil {
		return errcode.ErrCryptoKeyGeneration.Wrap(err)
	}

	// Set own Ephemeral priv key in Handshake Context
	hc.ownEphemeral = ownEphemeralPriv

	// Send own Ephemeral pub key to peer
	hello := HelloPayload{EphemeralPubKey: ownEphemeralPub[:]}
	if err := hc.writer.WriteMsg(&hello); err != nil {
		return errcode.ErrStreamWrite.Wrap(err)
	}

	return nil
}

// Receives peer's Ephemeral pub key
func (hc *handshakeContext) receivePeerEphemeralPubKey() error {
	var err error

	// Receive peer's Ephemeral pub key
	hello := HelloPayload{}
	if err := hc.reader.ReadMsg(&hello); err != nil {
		return errcode.ErrStreamRead.Wrap(err)
	}

	// Set peer's Ephemeral pub key in Handshake Context
	hc.peerEphemeral, err = cryptoutil.KeySliceToArray(hello.EphemeralPubKey)
	if err != nil {
		return errcode.ErrSerialization.Wrap(err)
	}

	return nil
}

// Computes box key for step 3 (Requester Authenticate): box[a.b|a.B]
func (hc *handshakeContext) computeRequesterAuthenticateBoxKey(asRequester bool) (*[cryptoutil.KeySize]byte, error) {
	var sharedReqEphemeralRespAccountID [cryptoutil.KeySize]byte

	// If this function was called by the requester
	if asRequester {
		// Convert Ed25519 peer's AccountID key to X25519 key
		mongPeerAccountID, err := cryptoutil.EdwardsToMontgomeryPub(hc.peerAccountID)
		if err != nil {
			return nil, errcode.ErrCryptoKeyConversion.Wrap(err)
		}

		// Compute shared key from own Ephemeral key and peer's AccountID key
		box.Precompute(
			&sharedReqEphemeralRespAccountID,
			mongPeerAccountID,
			hc.ownEphemeral,
		)
	} else {
		// Convert Ed25519 own AccountID key to X25519 key
		mongOwnAccountID, err := cryptoutil.EdwardsToMontgomeryPriv(hc.ownAccountID)
		if err != nil {
			return nil, errcode.ErrCryptoKeyConversion.Wrap(err)
		}

		// Compute shared key from peer's Ephemeral key and own AccountID key
		box.Precompute(
			&sharedReqEphemeralRespAccountID,
			hc.peerEphemeral,
			mongOwnAccountID,
		)
	}

	// Concatenate both shared keys and hash them using sha256
	boxKey := cryptoutil.ConcatAndHashSha256(
		hc.sharedEphemeral[:],
		sharedReqEphemeralRespAccountID[:],
	)

	return boxKey, nil
}

// Computes box key for step 4 (Responder Accept): box[a.b|A.B]
func (hc *handshakeContext) computeResponderAcceptBoxKey() (*[cryptoutil.KeySize]byte, error) {
	var sharedAccountID [cryptoutil.KeySize]byte

	// Convert Ed25519 AccountID keys to X25519 keys
	mongOwnAccountID, mongPeerAccountID, err := cryptoutil.EdwardsToMontgomery(
		hc.ownAccountID,
		hc.peerAccountID,
	)
	if err != nil {
		return nil, errcode.ErrCryptoKeyConversion.Wrap(err)
	}

	// Compute shared key from AccountID keys (X25519 converted)
	box.Precompute(&sharedAccountID, mongPeerAccountID, mongOwnAccountID)

	// Concatenate both shared keys and hash them using sha256
	boxKey := cryptoutil.ConcatAndHashSha256(
		hc.sharedEphemeral[:],
		sharedAccountID[:],
	)

	return boxKey, nil
}
