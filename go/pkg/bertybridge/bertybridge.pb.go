// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: bertybridge.proto

package bertybridge

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"

	errcode "berty.tech/berty/v2/go/pkg/errcode"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = proto.Marshal
	_ = fmt.Errorf
	_ = math.Inf
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type GRPCErrCode int32

const (
	// OK is returned on success.
	GRPCErrCode_OK GRPCErrCode = 0
	// Canceled indicates the operation was canceled (typically by the caller).
	//
	// The gRPC framework will generate this error code when cancellation
	// is requested.
	GRPCErrCode_CANCELED GRPCErrCode = 1
	// Unknown error. An example of where this error may be returned is
	// if a Status value received from another address space belongs to
	// an error-space that is not known in this address space. Also
	// errors raised by APIs that do not return enough error information
	// may be converted to this error.
	//
	// The gRPC framework will generate this error code in the above two
	// mentioned cases.
	GRPCErrCode_UNKNOWN GRPCErrCode = 2
	// InvalidArgument indicates client specified an invalid argument.
	// Note that this differs from FailedPrecondition. It indicates arguments
	// that are problematic regardless of the state of the system
	// (e.g., a malformed file name).
	//
	// This error code will not be generated by the gRPC framework.
	GRPCErrCode_INVALID_ARGUMENT GRPCErrCode = 3
	// DeadlineExceeded means operation expired before completion.
	// For operations that change the state of the system, this error may be
	// returned even if the operation has completed successfully. For
	// example, a successful response from a server could have been delayed
	// long enough for the deadline to expire.
	//
	// The gRPC framework will generate this error code when the deadline is
	// exceeded.
	GRPCErrCode_DEADLINE_EXCEEDED GRPCErrCode = 4
	// NotFound means some requested entity (e.g., file or directory) was
	// not found.
	//
	// This error code will not be generated by the gRPC framework.
	GRPCErrCode_NOT_FOUND GRPCErrCode = 5
	// AlreadyExists means an attempt to create an entity failed because one
	// already exists.
	//
	// This error code will not be generated by the gRPC framework.
	GRPCErrCode_ALREADY_EXISTS GRPCErrCode = 6
	// PermissionDenied indicates the caller does not have permission to
	// execute the specified operation. It must not be used for rejections
	// caused by exhausting some resource (use ResourceExhausted
	// instead for those errors). It must not be
	// used if the caller cannot be identified (use Unauthenticated
	// instead for those errors).
	//
	// This error code will not be generated by the gRPC core framework,
	// but expect authentication middleware to use it.
	GRPCErrCode_PERMISSION_DENIED GRPCErrCode = 7
	// ResourceExhausted indicates some resource has been exhausted, perhaps
	// a per-user quota, or perhaps the entire file system is out of space.
	//
	// This error code will be generated by the gRPC framework in
	// out-of-memory and server overload situations, or when a message is
	// larger than the configured maximum size.
	GRPCErrCode_RESOURCE_EXHAUSTED GRPCErrCode = 8
	// FailedPrecondition indicates operation was rejected because the
	// system is not in a state required for the operation's execution.
	// For example, directory to be deleted may be non-empty, an rmdir
	// operation is applied to a non-directory, etc.
	//
	// A litmus test that may help a service implementor in deciding
	// between FailedPrecondition, Aborted, and Unavailable:
	//  (a) Use Unavailable if the client can retry just the failing call.
	//  (b) Use Aborted if the client should retry at a higher-level
	//      (e.g., restarting a read-modify-write sequence).
	//  (c) Use FailedPrecondition if the client should not retry until
	//      the system state has been explicitly fixed. E.g., if an "rmdir"
	//      fails because the directory is non-empty, FailedPrecondition
	//      should be returned since the client should not retry unless
	//      they have first fixed up the directory by deleting files from it.
	//  (d) Use FailedPrecondition if the client performs conditional
	//      REST Get/Update/Delete on a resource and the resource on the
	//      server does not match the condition. E.g., conflicting
	//      read-modify-write on the same resource.
	//
	// This error code will not be generated by the gRPC framework.
	GRPCErrCode_FAILED_PRECONDITION GRPCErrCode = 9
	// Aborted indicates the operation was aborted, typically due to a
	// concurrency issue like sequencer check failures, transaction aborts,
	// etc.
	//
	// See litmus test above for deciding between FailedPrecondition,
	// Aborted, and Unavailable.
	//
	// This error code will not be generated by the gRPC framework.
	GRPCErrCode_ABORTED GRPCErrCode = 10
	// OutOfRange means operation was attempted past the valid range.
	// E.g., seeking or reading past end of file.
	//
	// Unlike InvalidArgument, this error indicates a problem that may
	// be fixed if the system state changes. For example, a 32-bit file
	// system will generate InvalidArgument if asked to read at an
	// offset that is not in the range [0,2^32-1], but it will generate
	// OutOfRange if asked to read from an offset past the current
	// file size.
	//
	// There is a fair bit of overlap between FailedPrecondition and
	// OutOfRange. We recommend using OutOfRange (the more specific
	// error) when it applies so that callers who are iterating through
	// a space can easily look for an OutOfRange error to detect when
	// they are done.
	//
	// This error code will not be generated by the gRPC framework.
	GRPCErrCode_OUT_OF_RANGE GRPCErrCode = 11
	// Unimplemented indicates operation is not implemented or not
	// supported/enabled in this service.
	//
	// This error code will be generated by the gRPC framework. Most
	// commonly, you will see this error code when a method implementation
	// is missing on the server. It can also be generated for unknown
	// compression algorithms or a disagreement as to whether an RPC should
	// be streaming.
	GRPCErrCode_UNIMPLEMENTED GRPCErrCode = 12
	// Internal errors. Means some invariants expected by underlying
	// system has been broken. If you see one of these errors,
	// something is very broken.
	//
	// This error code will be generated by the gRPC framework in several
	// internal error conditions.
	GRPCErrCode_INTERNAL GRPCErrCode = 13
	// Unavailable indicates the service is currently unavailable.
	// This is a most likely a transient condition and may be corrected
	// by retrying with a backoff. Note that it is not always safe to retry
	// non-idempotent operations.
	//
	// See litmus test above for deciding between FailedPrecondition,
	// Aborted, and Unavailable.
	//
	// This error code will be generated by the gRPC framework during
	// abrupt shutdown of a server process or network connection.
	GRPCErrCode_UNAVAILABLE GRPCErrCode = 14
	// DataLoss indicates unrecoverable data loss or corruption.
	//
	// This error code will not be generated by the gRPC framework.
	GRPCErrCode_DATA_LOSS GRPCErrCode = 15
	// Unauthenticated indicates the request does not have valid
	// authentication credentials for the operation.
	//
	// The gRPC framework will generate this error code when the
	// authentication metadata is invalid or a Credentials callback fails,
	// but also expect authentication middleware to generate it.
	GRPCErrCode_UNAUTHENTICATED GRPCErrCode = 16
)

var GRPCErrCode_name = map[int32]string{
	0:  "OK",
	1:  "CANCELED",
	2:  "UNKNOWN",
	3:  "INVALID_ARGUMENT",
	4:  "DEADLINE_EXCEEDED",
	5:  "NOT_FOUND",
	6:  "ALREADY_EXISTS",
	7:  "PERMISSION_DENIED",
	8:  "RESOURCE_EXHAUSTED",
	9:  "FAILED_PRECONDITION",
	10: "ABORTED",
	11: "OUT_OF_RANGE",
	12: "UNIMPLEMENTED",
	13: "INTERNAL",
	14: "UNAVAILABLE",
	15: "DATA_LOSS",
	16: "UNAUTHENTICATED",
}

var GRPCErrCode_value = map[string]int32{
	"OK":                  0,
	"CANCELED":            1,
	"UNKNOWN":             2,
	"INVALID_ARGUMENT":    3,
	"DEADLINE_EXCEEDED":   4,
	"NOT_FOUND":           5,
	"ALREADY_EXISTS":      6,
	"PERMISSION_DENIED":   7,
	"RESOURCE_EXHAUSTED":  8,
	"FAILED_PRECONDITION": 9,
	"ABORTED":             10,
	"OUT_OF_RANGE":        11,
	"UNIMPLEMENTED":       12,
	"INTERNAL":            13,
	"UNAVAILABLE":         14,
	"DATA_LOSS":           15,
	"UNAUTHENTICATED":     16,
}

func (x GRPCErrCode) String() string {
	return proto.EnumName(GRPCErrCode_name, int32(x))
}

func (GRPCErrCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_16edae2516c26cee, []int{0}
}

type ClientInvokeUnary struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientInvokeUnary) Reset()         { *m = ClientInvokeUnary{} }
func (m *ClientInvokeUnary) String() string { return proto.CompactTextString(m) }
func (*ClientInvokeUnary) ProtoMessage()    {}
func (*ClientInvokeUnary) Descriptor() ([]byte, []int) {
	return fileDescriptor_16edae2516c26cee, []int{0}
}

func (m *ClientInvokeUnary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *ClientInvokeUnary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientInvokeUnary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *ClientInvokeUnary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientInvokeUnary.Merge(m, src)
}

func (m *ClientInvokeUnary) XXX_Size() int {
	return m.Size()
}

func (m *ClientInvokeUnary) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientInvokeUnary.DiscardUnknown(m)
}

var xxx_messageInfo_ClientInvokeUnary proto.InternalMessageInfo

type ClientInvokeUnary_Request struct {
	MethodDesc           *MethodDesc `protobuf:"bytes,2,opt,name=method_desc,json=methodDesc,proto3" json:"method_desc,omitempty"`
	Payload              []byte      `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
	Header               []*Metadata `protobuf:"bytes,4,rep,name=header,proto3" json:"header,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ClientInvokeUnary_Request) Reset()         { *m = ClientInvokeUnary_Request{} }
func (m *ClientInvokeUnary_Request) String() string { return proto.CompactTextString(m) }
func (*ClientInvokeUnary_Request) ProtoMessage()    {}
func (*ClientInvokeUnary_Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_16edae2516c26cee, []int{0, 0}
}

func (m *ClientInvokeUnary_Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *ClientInvokeUnary_Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientInvokeUnary_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *ClientInvokeUnary_Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientInvokeUnary_Request.Merge(m, src)
}

func (m *ClientInvokeUnary_Request) XXX_Size() int {
	return m.Size()
}

func (m *ClientInvokeUnary_Request) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientInvokeUnary_Request.DiscardUnknown(m)
}

var xxx_messageInfo_ClientInvokeUnary_Request proto.InternalMessageInfo

func (m *ClientInvokeUnary_Request) GetMethodDesc() *MethodDesc {
	if m != nil {
		return m.MethodDesc
	}
	return nil
}

func (m *ClientInvokeUnary_Request) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *ClientInvokeUnary_Request) GetHeader() []*Metadata {
	if m != nil {
		return m.Header
	}
	return nil
}

type ClientInvokeUnary_Reply struct {
	Payload              []byte      `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	Trailer              []*Metadata `protobuf:"bytes,3,rep,name=trailer,proto3" json:"trailer,omitempty"`
	Error                *Error      `protobuf:"bytes,4,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ClientInvokeUnary_Reply) Reset()         { *m = ClientInvokeUnary_Reply{} }
func (m *ClientInvokeUnary_Reply) String() string { return proto.CompactTextString(m) }
func (*ClientInvokeUnary_Reply) ProtoMessage()    {}
func (*ClientInvokeUnary_Reply) Descriptor() ([]byte, []int) {
	return fileDescriptor_16edae2516c26cee, []int{0, 1}
}

func (m *ClientInvokeUnary_Reply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *ClientInvokeUnary_Reply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientInvokeUnary_Reply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *ClientInvokeUnary_Reply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientInvokeUnary_Reply.Merge(m, src)
}

func (m *ClientInvokeUnary_Reply) XXX_Size() int {
	return m.Size()
}

func (m *ClientInvokeUnary_Reply) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientInvokeUnary_Reply.DiscardUnknown(m)
}

var xxx_messageInfo_ClientInvokeUnary_Reply proto.InternalMessageInfo

func (m *ClientInvokeUnary_Reply) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *ClientInvokeUnary_Reply) GetTrailer() []*Metadata {
	if m != nil {
		return m.Trailer
	}
	return nil
}

func (m *ClientInvokeUnary_Reply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type ClientCreateStream struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientCreateStream) Reset()         { *m = ClientCreateStream{} }
func (m *ClientCreateStream) String() string { return proto.CompactTextString(m) }
func (*ClientCreateStream) ProtoMessage()    {}
func (*ClientCreateStream) Descriptor() ([]byte, []int) {
	return fileDescriptor_16edae2516c26cee, []int{1}
}

func (m *ClientCreateStream) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *ClientCreateStream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientCreateStream.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *ClientCreateStream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientCreateStream.Merge(m, src)
}

func (m *ClientCreateStream) XXX_Size() int {
	return m.Size()
}

func (m *ClientCreateStream) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientCreateStream.DiscardUnknown(m)
}

var xxx_messageInfo_ClientCreateStream proto.InternalMessageInfo

type ClientCreateStream_Request struct {
	MethodDesc           *MethodDesc `protobuf:"bytes,2,opt,name=method_desc,json=methodDesc,proto3" json:"method_desc,omitempty"`
	Payload              []byte      `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
	Header               []*Metadata `protobuf:"bytes,4,rep,name=header,proto3" json:"header,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ClientCreateStream_Request) Reset()         { *m = ClientCreateStream_Request{} }
func (m *ClientCreateStream_Request) String() string { return proto.CompactTextString(m) }
func (*ClientCreateStream_Request) ProtoMessage()    {}
func (*ClientCreateStream_Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_16edae2516c26cee, []int{1, 0}
}

func (m *ClientCreateStream_Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *ClientCreateStream_Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientCreateStream_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *ClientCreateStream_Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientCreateStream_Request.Merge(m, src)
}

func (m *ClientCreateStream_Request) XXX_Size() int {
	return m.Size()
}

func (m *ClientCreateStream_Request) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientCreateStream_Request.DiscardUnknown(m)
}

var xxx_messageInfo_ClientCreateStream_Request proto.InternalMessageInfo

func (m *ClientCreateStream_Request) GetMethodDesc() *MethodDesc {
	if m != nil {
		return m.MethodDesc
	}
	return nil
}

func (m *ClientCreateStream_Request) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *ClientCreateStream_Request) GetHeader() []*Metadata {
	if m != nil {
		return m.Header
	}
	return nil
}

type ClientCreateStream_Reply struct {
	StreamId             string      `protobuf:"bytes,1,opt,name=stream_id,json=streamId,proto3" json:"stream_id,omitempty"`
	Trailer              []*Metadata `protobuf:"bytes,2,rep,name=trailer,proto3" json:"trailer,omitempty"`
	Error                *Error      `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ClientCreateStream_Reply) Reset()         { *m = ClientCreateStream_Reply{} }
func (m *ClientCreateStream_Reply) String() string { return proto.CompactTextString(m) }
func (*ClientCreateStream_Reply) ProtoMessage()    {}
func (*ClientCreateStream_Reply) Descriptor() ([]byte, []int) {
	return fileDescriptor_16edae2516c26cee, []int{1, 1}
}

func (m *ClientCreateStream_Reply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *ClientCreateStream_Reply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientCreateStream_Reply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *ClientCreateStream_Reply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientCreateStream_Reply.Merge(m, src)
}

func (m *ClientCreateStream_Reply) XXX_Size() int {
	return m.Size()
}

func (m *ClientCreateStream_Reply) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientCreateStream_Reply.DiscardUnknown(m)
}

var xxx_messageInfo_ClientCreateStream_Reply proto.InternalMessageInfo

func (m *ClientCreateStream_Reply) GetStreamId() string {
	if m != nil {
		return m.StreamId
	}
	return ""
}

func (m *ClientCreateStream_Reply) GetTrailer() []*Metadata {
	if m != nil {
		return m.Trailer
	}
	return nil
}

func (m *ClientCreateStream_Reply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type ClientStreamSend struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientStreamSend) Reset()         { *m = ClientStreamSend{} }
func (m *ClientStreamSend) String() string { return proto.CompactTextString(m) }
func (*ClientStreamSend) ProtoMessage()    {}
func (*ClientStreamSend) Descriptor() ([]byte, []int) {
	return fileDescriptor_16edae2516c26cee, []int{2}
}

func (m *ClientStreamSend) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *ClientStreamSend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientStreamSend.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *ClientStreamSend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientStreamSend.Merge(m, src)
}

func (m *ClientStreamSend) XXX_Size() int {
	return m.Size()
}

func (m *ClientStreamSend) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientStreamSend.DiscardUnknown(m)
}

var xxx_messageInfo_ClientStreamSend proto.InternalMessageInfo

type ClientStreamSend_Request struct {
	StreamId             string   `protobuf:"bytes,1,opt,name=stream_id,json=streamId,proto3" json:"stream_id,omitempty"`
	Payload              []byte   `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientStreamSend_Request) Reset()         { *m = ClientStreamSend_Request{} }
func (m *ClientStreamSend_Request) String() string { return proto.CompactTextString(m) }
func (*ClientStreamSend_Request) ProtoMessage()    {}
func (*ClientStreamSend_Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_16edae2516c26cee, []int{2, 0}
}

func (m *ClientStreamSend_Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *ClientStreamSend_Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientStreamSend_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *ClientStreamSend_Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientStreamSend_Request.Merge(m, src)
}

func (m *ClientStreamSend_Request) XXX_Size() int {
	return m.Size()
}

func (m *ClientStreamSend_Request) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientStreamSend_Request.DiscardUnknown(m)
}

var xxx_messageInfo_ClientStreamSend_Request proto.InternalMessageInfo

func (m *ClientStreamSend_Request) GetStreamId() string {
	if m != nil {
		return m.StreamId
	}
	return ""
}

func (m *ClientStreamSend_Request) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type ClientStreamSend_Reply struct {
	StreamId             string      `protobuf:"bytes,1,opt,name=stream_id,json=streamId,proto3" json:"stream_id,omitempty"`
	Trailer              []*Metadata `protobuf:"bytes,2,rep,name=trailer,proto3" json:"trailer,omitempty"`
	Error                *Error      `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ClientStreamSend_Reply) Reset()         { *m = ClientStreamSend_Reply{} }
func (m *ClientStreamSend_Reply) String() string { return proto.CompactTextString(m) }
func (*ClientStreamSend_Reply) ProtoMessage()    {}
func (*ClientStreamSend_Reply) Descriptor() ([]byte, []int) {
	return fileDescriptor_16edae2516c26cee, []int{2, 1}
}

func (m *ClientStreamSend_Reply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *ClientStreamSend_Reply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientStreamSend_Reply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *ClientStreamSend_Reply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientStreamSend_Reply.Merge(m, src)
}

func (m *ClientStreamSend_Reply) XXX_Size() int {
	return m.Size()
}

func (m *ClientStreamSend_Reply) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientStreamSend_Reply.DiscardUnknown(m)
}

var xxx_messageInfo_ClientStreamSend_Reply proto.InternalMessageInfo

func (m *ClientStreamSend_Reply) GetStreamId() string {
	if m != nil {
		return m.StreamId
	}
	return ""
}

func (m *ClientStreamSend_Reply) GetTrailer() []*Metadata {
	if m != nil {
		return m.Trailer
	}
	return nil
}

func (m *ClientStreamSend_Reply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type ClientStreamRecv struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientStreamRecv) Reset()         { *m = ClientStreamRecv{} }
func (m *ClientStreamRecv) String() string { return proto.CompactTextString(m) }
func (*ClientStreamRecv) ProtoMessage()    {}
func (*ClientStreamRecv) Descriptor() ([]byte, []int) {
	return fileDescriptor_16edae2516c26cee, []int{3}
}

func (m *ClientStreamRecv) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *ClientStreamRecv) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientStreamRecv.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *ClientStreamRecv) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientStreamRecv.Merge(m, src)
}

func (m *ClientStreamRecv) XXX_Size() int {
	return m.Size()
}

func (m *ClientStreamRecv) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientStreamRecv.DiscardUnknown(m)
}

var xxx_messageInfo_ClientStreamRecv proto.InternalMessageInfo

type ClientStreamRecv_Request struct {
	StreamId             string   `protobuf:"bytes,1,opt,name=stream_id,json=streamId,proto3" json:"stream_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientStreamRecv_Request) Reset()         { *m = ClientStreamRecv_Request{} }
func (m *ClientStreamRecv_Request) String() string { return proto.CompactTextString(m) }
func (*ClientStreamRecv_Request) ProtoMessage()    {}
func (*ClientStreamRecv_Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_16edae2516c26cee, []int{3, 0}
}

func (m *ClientStreamRecv_Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *ClientStreamRecv_Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientStreamRecv_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *ClientStreamRecv_Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientStreamRecv_Request.Merge(m, src)
}

func (m *ClientStreamRecv_Request) XXX_Size() int {
	return m.Size()
}

func (m *ClientStreamRecv_Request) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientStreamRecv_Request.DiscardUnknown(m)
}

var xxx_messageInfo_ClientStreamRecv_Request proto.InternalMessageInfo

func (m *ClientStreamRecv_Request) GetStreamId() string {
	if m != nil {
		return m.StreamId
	}
	return ""
}

type ClientStreamRecv_Reply struct {
	StreamId             string      `protobuf:"bytes,1,opt,name=stream_id,json=streamId,proto3" json:"stream_id,omitempty"`
	Payload              []byte      `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	Trailer              []*Metadata `protobuf:"bytes,3,rep,name=trailer,proto3" json:"trailer,omitempty"`
	Error                *Error      `protobuf:"bytes,4,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ClientStreamRecv_Reply) Reset()         { *m = ClientStreamRecv_Reply{} }
func (m *ClientStreamRecv_Reply) String() string { return proto.CompactTextString(m) }
func (*ClientStreamRecv_Reply) ProtoMessage()    {}
func (*ClientStreamRecv_Reply) Descriptor() ([]byte, []int) {
	return fileDescriptor_16edae2516c26cee, []int{3, 1}
}

func (m *ClientStreamRecv_Reply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *ClientStreamRecv_Reply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientStreamRecv_Reply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *ClientStreamRecv_Reply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientStreamRecv_Reply.Merge(m, src)
}

func (m *ClientStreamRecv_Reply) XXX_Size() int {
	return m.Size()
}

func (m *ClientStreamRecv_Reply) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientStreamRecv_Reply.DiscardUnknown(m)
}

var xxx_messageInfo_ClientStreamRecv_Reply proto.InternalMessageInfo

func (m *ClientStreamRecv_Reply) GetStreamId() string {
	if m != nil {
		return m.StreamId
	}
	return ""
}

func (m *ClientStreamRecv_Reply) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *ClientStreamRecv_Reply) GetTrailer() []*Metadata {
	if m != nil {
		return m.Trailer
	}
	return nil
}

func (m *ClientStreamRecv_Reply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type ClientStreamClose struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientStreamClose) Reset()         { *m = ClientStreamClose{} }
func (m *ClientStreamClose) String() string { return proto.CompactTextString(m) }
func (*ClientStreamClose) ProtoMessage()    {}
func (*ClientStreamClose) Descriptor() ([]byte, []int) {
	return fileDescriptor_16edae2516c26cee, []int{4}
}

func (m *ClientStreamClose) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *ClientStreamClose) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientStreamClose.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *ClientStreamClose) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientStreamClose.Merge(m, src)
}

func (m *ClientStreamClose) XXX_Size() int {
	return m.Size()
}

func (m *ClientStreamClose) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientStreamClose.DiscardUnknown(m)
}

var xxx_messageInfo_ClientStreamClose proto.InternalMessageInfo

type ClientStreamClose_Request struct {
	StreamId             string   `protobuf:"bytes,1,opt,name=stream_id,json=streamId,proto3" json:"stream_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientStreamClose_Request) Reset()         { *m = ClientStreamClose_Request{} }
func (m *ClientStreamClose_Request) String() string { return proto.CompactTextString(m) }
func (*ClientStreamClose_Request) ProtoMessage()    {}
func (*ClientStreamClose_Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_16edae2516c26cee, []int{4, 0}
}

func (m *ClientStreamClose_Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *ClientStreamClose_Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientStreamClose_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *ClientStreamClose_Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientStreamClose_Request.Merge(m, src)
}

func (m *ClientStreamClose_Request) XXX_Size() int {
	return m.Size()
}

func (m *ClientStreamClose_Request) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientStreamClose_Request.DiscardUnknown(m)
}

var xxx_messageInfo_ClientStreamClose_Request proto.InternalMessageInfo

func (m *ClientStreamClose_Request) GetStreamId() string {
	if m != nil {
		return m.StreamId
	}
	return ""
}

type ClientStreamClose_Reply struct {
	StreamId             string      `protobuf:"bytes,1,opt,name=stream_id,json=streamId,proto3" json:"stream_id,omitempty"`
	Trailer              []*Metadata `protobuf:"bytes,2,rep,name=trailer,proto3" json:"trailer,omitempty"`
	Error                *Error      `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ClientStreamClose_Reply) Reset()         { *m = ClientStreamClose_Reply{} }
func (m *ClientStreamClose_Reply) String() string { return proto.CompactTextString(m) }
func (*ClientStreamClose_Reply) ProtoMessage()    {}
func (*ClientStreamClose_Reply) Descriptor() ([]byte, []int) {
	return fileDescriptor_16edae2516c26cee, []int{4, 1}
}

func (m *ClientStreamClose_Reply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *ClientStreamClose_Reply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientStreamClose_Reply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *ClientStreamClose_Reply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientStreamClose_Reply.Merge(m, src)
}

func (m *ClientStreamClose_Reply) XXX_Size() int {
	return m.Size()
}

func (m *ClientStreamClose_Reply) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientStreamClose_Reply.DiscardUnknown(m)
}

var xxx_messageInfo_ClientStreamClose_Reply proto.InternalMessageInfo

func (m *ClientStreamClose_Reply) GetStreamId() string {
	if m != nil {
		return m.StreamId
	}
	return ""
}

func (m *ClientStreamClose_Reply) GetTrailer() []*Metadata {
	if m != nil {
		return m.Trailer
	}
	return nil
}

func (m *ClientStreamClose_Reply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type ClientStreamCloseAndRecv struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientStreamCloseAndRecv) Reset()         { *m = ClientStreamCloseAndRecv{} }
func (m *ClientStreamCloseAndRecv) String() string { return proto.CompactTextString(m) }
func (*ClientStreamCloseAndRecv) ProtoMessage()    {}
func (*ClientStreamCloseAndRecv) Descriptor() ([]byte, []int) {
	return fileDescriptor_16edae2516c26cee, []int{5}
}

func (m *ClientStreamCloseAndRecv) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *ClientStreamCloseAndRecv) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientStreamCloseAndRecv.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *ClientStreamCloseAndRecv) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientStreamCloseAndRecv.Merge(m, src)
}

func (m *ClientStreamCloseAndRecv) XXX_Size() int {
	return m.Size()
}

func (m *ClientStreamCloseAndRecv) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientStreamCloseAndRecv.DiscardUnknown(m)
}

var xxx_messageInfo_ClientStreamCloseAndRecv proto.InternalMessageInfo

type ClientStreamCloseAndRecv_Request struct {
	StreamId             string   `protobuf:"bytes,1,opt,name=stream_id,json=streamId,proto3" json:"stream_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientStreamCloseAndRecv_Request) Reset()         { *m = ClientStreamCloseAndRecv_Request{} }
func (m *ClientStreamCloseAndRecv_Request) String() string { return proto.CompactTextString(m) }
func (*ClientStreamCloseAndRecv_Request) ProtoMessage()    {}
func (*ClientStreamCloseAndRecv_Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_16edae2516c26cee, []int{5, 0}
}

func (m *ClientStreamCloseAndRecv_Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *ClientStreamCloseAndRecv_Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientStreamCloseAndRecv_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *ClientStreamCloseAndRecv_Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientStreamCloseAndRecv_Request.Merge(m, src)
}

func (m *ClientStreamCloseAndRecv_Request) XXX_Size() int {
	return m.Size()
}

func (m *ClientStreamCloseAndRecv_Request) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientStreamCloseAndRecv_Request.DiscardUnknown(m)
}

var xxx_messageInfo_ClientStreamCloseAndRecv_Request proto.InternalMessageInfo

func (m *ClientStreamCloseAndRecv_Request) GetStreamId() string {
	if m != nil {
		return m.StreamId
	}
	return ""
}

type ClientStreamCloseAndRecv_Reply struct {
	StreamId             string      `protobuf:"bytes,1,opt,name=stream_id,json=streamId,proto3" json:"stream_id,omitempty"`
	Payload              []byte      `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	Trailer              []*Metadata `protobuf:"bytes,3,rep,name=trailer,proto3" json:"trailer,omitempty"`
	Error                *Error      `protobuf:"bytes,4,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ClientStreamCloseAndRecv_Reply) Reset()         { *m = ClientStreamCloseAndRecv_Reply{} }
func (m *ClientStreamCloseAndRecv_Reply) String() string { return proto.CompactTextString(m) }
func (*ClientStreamCloseAndRecv_Reply) ProtoMessage()    {}
func (*ClientStreamCloseAndRecv_Reply) Descriptor() ([]byte, []int) {
	return fileDescriptor_16edae2516c26cee, []int{5, 1}
}

func (m *ClientStreamCloseAndRecv_Reply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *ClientStreamCloseAndRecv_Reply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientStreamCloseAndRecv_Reply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *ClientStreamCloseAndRecv_Reply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientStreamCloseAndRecv_Reply.Merge(m, src)
}

func (m *ClientStreamCloseAndRecv_Reply) XXX_Size() int {
	return m.Size()
}

func (m *ClientStreamCloseAndRecv_Reply) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientStreamCloseAndRecv_Reply.DiscardUnknown(m)
}

var xxx_messageInfo_ClientStreamCloseAndRecv_Reply proto.InternalMessageInfo

func (m *ClientStreamCloseAndRecv_Reply) GetStreamId() string {
	if m != nil {
		return m.StreamId
	}
	return ""
}

func (m *ClientStreamCloseAndRecv_Reply) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *ClientStreamCloseAndRecv_Reply) GetTrailer() []*Metadata {
	if m != nil {
		return m.Trailer
	}
	return nil
}

func (m *ClientStreamCloseAndRecv_Reply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type MethodDesc struct {
	// Name is the method name only, without the service name or package name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// IsClientStream indicates whether the RPC is a client streaming RPC.
	IsClientStream bool `protobuf:"varint,2,opt,name=is_client_stream,json=isClientStream,proto3" json:"is_client_stream,omitempty"`
	// IsServerStream indicates whether the RPC is a server streaming RPC.
	IsServerStream       bool     `protobuf:"varint,3,opt,name=is_server_stream,json=isServerStream,proto3" json:"is_server_stream,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MethodDesc) Reset()         { *m = MethodDesc{} }
func (m *MethodDesc) String() string { return proto.CompactTextString(m) }
func (*MethodDesc) ProtoMessage()    {}
func (*MethodDesc) Descriptor() ([]byte, []int) {
	return fileDescriptor_16edae2516c26cee, []int{6}
}

func (m *MethodDesc) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *MethodDesc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MethodDesc.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *MethodDesc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MethodDesc.Merge(m, src)
}

func (m *MethodDesc) XXX_Size() int {
	return m.Size()
}

func (m *MethodDesc) XXX_DiscardUnknown() {
	xxx_messageInfo_MethodDesc.DiscardUnknown(m)
}

var xxx_messageInfo_MethodDesc proto.InternalMessageInfo

func (m *MethodDesc) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MethodDesc) GetIsClientStream() bool {
	if m != nil {
		return m.IsClientStream
	}
	return false
}

func (m *MethodDesc) GetIsServerStream() bool {
	if m != nil {
		return m.IsServerStream
	}
	return false
}

type Metadata struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Values               []string `protobuf:"bytes,2,rep,name=values,proto3" json:"values,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Metadata) Reset()         { *m = Metadata{} }
func (m *Metadata) String() string { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()    {}
func (*Metadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_16edae2516c26cee, []int{7}
}

func (m *Metadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *Metadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *Metadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metadata.Merge(m, src)
}

func (m *Metadata) XXX_Size() int {
	return m.Size()
}

func (m *Metadata) XXX_DiscardUnknown() {
	xxx_messageInfo_Metadata.DiscardUnknown(m)
}

var xxx_messageInfo_Metadata proto.InternalMessageInfo

func (m *Metadata) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Metadata) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

type Error struct {
	// grpc error code
	GrpcErrorCode GRPCErrCode `protobuf:"varint,1,opt,name=grpc_error_code,json=grpcErrorCode,proto3,enum=berty.bridge.v1.GRPCErrCode" json:"grpc_error_code,omitempty"`
	// toplevel error
	ErrorCode errcode.ErrCode `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3,enum=berty.errcode.ErrCode" json:"error_code,omitempty"`
	// toplevel error message
	Message string `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	// detailed errors
	ErrorDetails         *errcode.ErrDetails `protobuf:"bytes,4,opt,name=error_details,json=errorDetails,proto3" json:"error_details,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()    {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_16edae2516c26cee, []int{8}
}

func (m *Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}

func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Error.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}

func (m *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(m, src)
}

func (m *Error) XXX_Size() int {
	return m.Size()
}

func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

func (m *Error) GetGrpcErrorCode() GRPCErrCode {
	if m != nil {
		return m.GrpcErrorCode
	}
	return GRPCErrCode_OK
}

func (m *Error) GetErrorCode() errcode.ErrCode {
	if m != nil {
		return m.ErrorCode
	}
	return errcode.Undefined
}

func (m *Error) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Error) GetErrorDetails() *errcode.ErrDetails {
	if m != nil {
		return m.ErrorDetails
	}
	return nil
}

func init() {
	proto.RegisterEnum("berty.bridge.v1.GRPCErrCode", GRPCErrCode_name, GRPCErrCode_value)
	proto.RegisterType((*ClientInvokeUnary)(nil), "berty.bridge.v1.ClientInvokeUnary")
	proto.RegisterType((*ClientInvokeUnary_Request)(nil), "berty.bridge.v1.ClientInvokeUnary.Request")
	proto.RegisterType((*ClientInvokeUnary_Reply)(nil), "berty.bridge.v1.ClientInvokeUnary.Reply")
	proto.RegisterType((*ClientCreateStream)(nil), "berty.bridge.v1.ClientCreateStream")
	proto.RegisterType((*ClientCreateStream_Request)(nil), "berty.bridge.v1.ClientCreateStream.Request")
	proto.RegisterType((*ClientCreateStream_Reply)(nil), "berty.bridge.v1.ClientCreateStream.Reply")
	proto.RegisterType((*ClientStreamSend)(nil), "berty.bridge.v1.ClientStreamSend")
	proto.RegisterType((*ClientStreamSend_Request)(nil), "berty.bridge.v1.ClientStreamSend.Request")
	proto.RegisterType((*ClientStreamSend_Reply)(nil), "berty.bridge.v1.ClientStreamSend.Reply")
	proto.RegisterType((*ClientStreamRecv)(nil), "berty.bridge.v1.ClientStreamRecv")
	proto.RegisterType((*ClientStreamRecv_Request)(nil), "berty.bridge.v1.ClientStreamRecv.Request")
	proto.RegisterType((*ClientStreamRecv_Reply)(nil), "berty.bridge.v1.ClientStreamRecv.Reply")
	proto.RegisterType((*ClientStreamClose)(nil), "berty.bridge.v1.ClientStreamClose")
	proto.RegisterType((*ClientStreamClose_Request)(nil), "berty.bridge.v1.ClientStreamClose.Request")
	proto.RegisterType((*ClientStreamClose_Reply)(nil), "berty.bridge.v1.ClientStreamClose.Reply")
	proto.RegisterType((*ClientStreamCloseAndRecv)(nil), "berty.bridge.v1.ClientStreamCloseAndRecv")
	proto.RegisterType((*ClientStreamCloseAndRecv_Request)(nil), "berty.bridge.v1.ClientStreamCloseAndRecv.Request")
	proto.RegisterType((*ClientStreamCloseAndRecv_Reply)(nil), "berty.bridge.v1.ClientStreamCloseAndRecv.Reply")
	proto.RegisterType((*MethodDesc)(nil), "berty.bridge.v1.MethodDesc")
	proto.RegisterType((*Metadata)(nil), "berty.bridge.v1.Metadata")
	proto.RegisterType((*Error)(nil), "berty.bridge.v1.Error")
}

func init() { proto.RegisterFile("bertybridge.proto", fileDescriptor_16edae2516c26cee) }

var fileDescriptor_16edae2516c26cee = []byte{
	// 957 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x56, 0x4d, 0x6f, 0xe3, 0x44,
	0x18, 0xc6, 0x49, 0x9b, 0x8f, 0x37, 0x49, 0x33, 0x9d, 0x5d, 0x4a, 0x36, 0x8b, 0xaa, 0xaa, 0x48,
	0x10, 0x16, 0x94, 0xa8, 0x5d, 0xb8, 0x21, 0x84, 0x6b, 0x4f, 0xbb, 0xd6, 0xba, 0xe3, 0x6a, 0x6c,
	0x2f, 0x0b, 0x17, 0xcb, 0x8d, 0x87, 0xd4, 0x6a, 0x12, 0x07, 0xdb, 0x1b, 0x29, 0x17, 0x4e, 0x48,
	0xfc, 0x01, 0xfe, 0x00, 0xe2, 0x17, 0x70, 0xe0, 0xc8, 0x11, 0x89, 0x23, 0xbf, 0x00, 0xa1, 0x1e,
	0xf8, 0x1d, 0x68, 0xfc, 0x91, 0xa6, 0xa4, 0xa1, 0xd9, 0x13, 0x15, 0xb7, 0x99, 0xf1, 0xf3, 0x3e,
	0xef, 0xf3, 0x3e, 0xaf, 0xe7, 0x03, 0xb6, 0xcf, 0x79, 0x18, 0xcf, 0xce, 0x43, 0xdf, 0x1b, 0xf0,
	0xee, 0x24, 0x0c, 0xe2, 0x00, 0x37, 0x93, 0xa5, 0x6e, 0xb6, 0x36, 0x3d, 0x68, 0x3f, 0x1c, 0x04,
	0x83, 0x20, 0xf9, 0xd6, 0x13, 0xa3, 0x14, 0xd6, 0x6e, 0xf0, 0x30, 0xec, 0x07, 0x5e, 0x16, 0xb5,
	0xff, 0x53, 0x01, 0xb6, 0x95, 0xa1, 0xcf, 0xc7, 0xb1, 0x36, 0x9e, 0x06, 0x97, 0xdc, 0x1e, 0xbb,
	0xe1, 0xac, 0xfd, 0xbd, 0x04, 0x65, 0xc6, 0xbf, 0x7e, 0xc5, 0xa3, 0x18, 0x7f, 0x02, 0xb5, 0x11,
	0x8f, 0x2f, 0x02, 0xcf, 0xf1, 0x78, 0xd4, 0x6f, 0x15, 0xf6, 0xa4, 0x4e, 0xed, 0xf0, 0x71, 0xf7,
	0x1f, 0xd9, 0xba, 0xa7, 0x09, 0x46, 0xe5, 0x51, 0x9f, 0xc1, 0x68, 0x3e, 0xc6, 0x2d, 0x28, 0x4f,
	0xdc, 0xd9, 0x30, 0x70, 0xbd, 0x56, 0x71, 0x4f, 0xea, 0xd4, 0x59, 0x3e, 0xc5, 0x07, 0x50, 0xba,
	0xe0, 0xae, 0xc7, 0xc3, 0xd6, 0xc6, 0x5e, 0xb1, 0x53, 0x3b, 0x7c, 0x74, 0x1b, 0xa5, 0xeb, 0xb9,
	0xb1, 0xcb, 0x32, 0x60, 0xfb, 0x5b, 0x09, 0x36, 0x19, 0x9f, 0x0c, 0x67, 0x8b, 0xb4, 0x85, 0x9b,
	0xb4, 0x4f, 0xa1, 0x1c, 0x87, 0xae, 0x3f, 0xe4, 0x61, 0xab, 0x78, 0x17, 0x6f, 0x8e, 0xc4, 0x1f,
	0xc2, 0x26, 0x0f, 0xc3, 0x40, 0x48, 0x11, 0xd5, 0xed, 0x2c, 0x85, 0x10, 0xf1, 0x95, 0xa5, 0xa0,
	0xfd, 0x9f, 0x0b, 0x80, 0x53, 0xcf, 0x94, 0x90, 0xbb, 0x31, 0x37, 0xe3, 0x90, 0xbb, 0xa3, 0xfb,
	0x6a, 0xda, 0x77, 0x73, 0xd3, 0x1e, 0x43, 0x35, 0x4a, 0xa4, 0x3a, 0xbe, 0xd7, 0x92, 0xf6, 0xa4,
	0x4e, 0x95, 0x55, 0xd2, 0x05, 0xed, 0x86, 0x6f, 0x85, 0xd7, 0xf7, 0xad, 0xb8, 0x8e, 0x6f, 0x7f,
	0x48, 0x80, 0x52, 0xdf, 0x52, 0xc7, 0x4c, 0x3e, 0xf6, 0xda, 0x9f, 0x5d, 0x9b, 0xf6, 0xaf, 0xfa,
	0x56, 0x76, 0xfc, 0x1e, 0x17, 0xc8, 0x78, 0x7f, 0xda, 0x7e, 0x77, 0xbd, 0x02, 0xdb, 0x3f, 0xac,
	0x57, 0xc6, 0x7f, 0xfa, 0xe7, 0xff, 0x2a, 0xe5, 0xa7, 0x45, 0x5a, 0xa0, 0x32, 0x0c, 0x22, 0xbe,
	0x76, 0x85, 0xf7, 0xa7, 0x51, 0x7f, 0x49, 0xd0, 0x5a, 0xaa, 0x43, 0x1e, 0x7b, 0xff, 0xbb, 0x86,
	0xc5, 0x00, 0xd7, 0x67, 0x0c, 0xc6, 0xb0, 0x31, 0x76, 0x47, 0x3c, 0x93, 0x98, 0x8c, 0x71, 0x07,
	0x90, 0x1f, 0x39, 0xfd, 0xc4, 0x0c, 0x27, 0x15, 0x9d, 0xe8, 0xac, 0xb0, 0x2d, 0x3f, 0x5a, 0xf4,
	0x28, 0x43, 0x46, 0x3c, 0x9c, 0xf2, 0x30, 0x47, 0x16, 0x73, 0xa4, 0x99, 0x2c, 0xa7, 0xc8, 0xfd,
	0x8f, 0xa0, 0x92, 0x0b, 0xc7, 0x08, 0x8a, 0x97, 0x7c, 0x96, 0xa5, 0x14, 0x43, 0xbc, 0x03, 0xa5,
	0xa9, 0x3b, 0x7c, 0xc5, 0xa3, 0xa4, 0xbd, 0x55, 0x96, 0xcd, 0xc4, 0xee, 0xd9, 0x4c, 0xc4, 0x63,
	0x15, 0x9a, 0x83, 0x70, 0xd2, 0x77, 0x92, 0x1a, 0x1c, 0x71, 0x5b, 0x25, 0xf1, 0x5b, 0x87, 0x6f,
	0x2f, 0x55, 0x7b, 0xc2, 0xce, 0x14, 0x12, 0x86, 0x4a, 0xe0, 0x71, 0xd6, 0x10, 0x41, 0x09, 0x83,
	0x98, 0xe2, 0x8f, 0x01, 0x16, 0x08, 0x0a, 0x09, 0x41, 0x6e, 0x57, 0x7e, 0x09, 0xe6, 0xa1, 0x55,
	0x3e, 0x0f, 0x6b, 0x41, 0x79, 0xc4, 0xa3, 0xc8, 0x1d, 0xf0, 0xa4, 0xba, 0x2a, 0xcb, 0xa7, 0xf8,
	0x53, 0x68, 0xa4, 0x84, 0x1e, 0x8f, 0x5d, 0x7f, 0x18, 0x65, 0x2d, 0x78, 0xb4, 0xcc, 0xa9, 0xa6,
	0x00, 0x56, 0x4f, 0xf0, 0xd9, 0xec, 0xc9, 0x2f, 0x05, 0xa8, 0x2d, 0xe8, 0xc5, 0x25, 0x28, 0x18,
	0xcf, 0xd1, 0x1b, 0xb8, 0x0e, 0x15, 0x45, 0xa6, 0x0a, 0xd1, 0x89, 0x8a, 0x24, 0x5c, 0x83, 0xb2,
	0x4d, 0x9f, 0x53, 0xe3, 0x73, 0x8a, 0x0a, 0xf8, 0x21, 0x20, 0x8d, 0xbe, 0x90, 0x75, 0x4d, 0x75,
	0x64, 0x76, 0x62, 0x9f, 0x12, 0x6a, 0xa1, 0x22, 0x7e, 0x13, 0xb6, 0x55, 0x22, 0xab, 0xba, 0x46,
	0x89, 0x43, 0x5e, 0x2a, 0x84, 0xa8, 0x44, 0x45, 0x1b, 0xb8, 0x01, 0x55, 0x6a, 0x58, 0xce, 0xb1,
	0x61, 0x53, 0x15, 0x6d, 0x62, 0x0c, 0x5b, 0xb2, 0xce, 0x88, 0xac, 0x7e, 0xe1, 0x90, 0x97, 0x9a,
	0x69, 0x99, 0xa8, 0x24, 0x22, 0xcf, 0x08, 0x3b, 0xd5, 0x4c, 0x53, 0x33, 0xa8, 0xa3, 0x12, 0xaa,
	0x11, 0x15, 0x95, 0xf1, 0x0e, 0x60, 0x46, 0x4c, 0xc3, 0x66, 0x8a, 0x20, 0x7c, 0x26, 0xdb, 0xa6,
	0x45, 0x54, 0x54, 0xc1, 0x6f, 0xc1, 0x83, 0x63, 0x59, 0xd3, 0x89, 0xea, 0x9c, 0x31, 0xa2, 0x18,
	0x54, 0xd5, 0x2c, 0xcd, 0xa0, 0xa8, 0x2a, 0x44, 0xca, 0x47, 0x06, 0x13, 0x28, 0xc0, 0x08, 0xea,
	0x86, 0x6d, 0x39, 0xc6, 0xb1, 0xc3, 0x64, 0x7a, 0x42, 0x50, 0x0d, 0x6f, 0x43, 0xc3, 0xa6, 0xda,
	0xe9, 0x99, 0x4e, 0x84, 0x62, 0xa2, 0xa2, 0xba, 0x28, 0x52, 0xa3, 0x16, 0x61, 0x54, 0xd6, 0x51,
	0x03, 0x37, 0xa1, 0x66, 0x53, 0xf9, 0x85, 0xac, 0xe9, 0xf2, 0x91, 0x4e, 0xd0, 0x96, 0xd0, 0xae,
	0xca, 0x96, 0xec, 0xe8, 0x86, 0x69, 0xa2, 0x26, 0x7e, 0x00, 0x4d, 0x9b, 0xca, 0xb6, 0xf5, 0x8c,
	0x50, 0x4b, 0x53, 0x64, 0x41, 0x81, 0x0e, 0x7f, 0xdc, 0x84, 0xc6, 0x51, 0xd2, 0x79, 0xf1, 0xb7,
	0xf9, 0x7d, 0x8e, 0xfd, 0x5b, 0x1e, 0x2f, 0xf8, 0xc9, 0xd2, 0x4f, 0xb2, 0x84, 0xe9, 0x66, 0x1b,
	0xbc, 0xdd, 0x59, 0x0b, 0x2b, 0xf6, 0xf8, 0x10, 0x70, 0x7a, 0xdb, 0xdf, 0xd8, 0x13, 0x1f, 0xac,
	0x88, 0x5f, 0x7c, 0x18, 0xcc, 0x93, 0xbd, 0xbf, 0x1e, 0x58, 0x64, 0xfb, 0x6a, 0xf9, 0xa6, 0xc4,
	0xab, 0xc2, 0xaf, 0x21, 0xf3, 0x4c, 0xef, 0xad, 0x03, 0xbd, 0x25, 0x8f, 0x38, 0xff, 0xee, 0xc8,
	0x23, 0x20, 0x6b, 0xe6, 0xc9, 0xa0, 0x22, 0x8f, 0x7f, 0xcb, 0xbd, 0xb1, 0xb2, 0x51, 0x0b, 0x98,
	0x3b, 0x1b, 0x75, 0x13, 0x2b, 0x52, 0x7d, 0xb3, 0xfa, 0x68, 0xc7, 0x07, 0x77, 0xb3, 0x64, 0xd0,
	0x79, 0xe2, 0xde, 0xeb, 0x84, 0x4c, 0x86, 0xb3, 0xa3, 0x83, 0xdf, 0xae, 0x76, 0xa5, 0xdf, 0xaf,
	0x76, 0xa5, 0x3f, 0xaf, 0x76, 0xa5, 0x2f, 0xdf, 0x49, 0xa3, 0x63, 0xde, 0xbf, 0xe8, 0x25, 0xc3,
	0xde, 0x20, 0xe8, 0x4d, 0x2e, 0x07, 0xbd, 0x85, 0x07, 0xfc, 0x79, 0x29, 0x79, 0x8b, 0x3f, 0xfd,
	0x3b, 0x00, 0x00, 0xff, 0xff, 0xa2, 0x1f, 0x19, 0x7a, 0xd6, 0x0b, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ context.Context
	_ grpc.ClientConn
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BridgeServiceClient is the client API for BridgeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BridgeServiceClient interface {
	// ClientInvokeUnary invoke a unary method
	ClientInvokeUnary(ctx context.Context, in *ClientInvokeUnary_Request, opts ...grpc.CallOption) (*ClientInvokeUnary_Reply, error)
	// CreateStream create a stream
	CreateClientStream(ctx context.Context, in *ClientCreateStream_Request, opts ...grpc.CallOption) (*ClientCreateStream_Reply, error)
	// Send Message over the given stream
	ClientStreamSend(ctx context.Context, in *ClientStreamSend_Request, opts ...grpc.CallOption) (*ClientStreamSend_Reply, error)
	// Recv message over the given stream
	ClientStreamRecv(ctx context.Context, in *ClientStreamRecv_Request, opts ...grpc.CallOption) (*ClientStreamRecv_Reply, error)
	// Close the given stream (should not be used)
	ClientStreamClose(ctx context.Context, in *ClientStreamClose_Request, opts ...grpc.CallOption) (*ClientStreamClose_Reply, error)
	// Close the writing end of a stream and return the next reply
	ClientStreamCloseAndRecv(ctx context.Context, in *ClientStreamCloseAndRecv_Request, opts ...grpc.CallOption) (*ClientStreamCloseAndRecv_Reply, error)
}

type bridgeServiceClient struct {
	cc *grpc.ClientConn
}

func NewBridgeServiceClient(cc *grpc.ClientConn) BridgeServiceClient {
	return &bridgeServiceClient{cc}
}

func (c *bridgeServiceClient) ClientInvokeUnary(ctx context.Context, in *ClientInvokeUnary_Request, opts ...grpc.CallOption) (*ClientInvokeUnary_Reply, error) {
	out := new(ClientInvokeUnary_Reply)
	err := c.cc.Invoke(ctx, "/berty.bridge.v1.BridgeService/ClientInvokeUnary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeServiceClient) CreateClientStream(ctx context.Context, in *ClientCreateStream_Request, opts ...grpc.CallOption) (*ClientCreateStream_Reply, error) {
	out := new(ClientCreateStream_Reply)
	err := c.cc.Invoke(ctx, "/berty.bridge.v1.BridgeService/CreateClientStream", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeServiceClient) ClientStreamSend(ctx context.Context, in *ClientStreamSend_Request, opts ...grpc.CallOption) (*ClientStreamSend_Reply, error) {
	out := new(ClientStreamSend_Reply)
	err := c.cc.Invoke(ctx, "/berty.bridge.v1.BridgeService/ClientStreamSend", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeServiceClient) ClientStreamRecv(ctx context.Context, in *ClientStreamRecv_Request, opts ...grpc.CallOption) (*ClientStreamRecv_Reply, error) {
	out := new(ClientStreamRecv_Reply)
	err := c.cc.Invoke(ctx, "/berty.bridge.v1.BridgeService/ClientStreamRecv", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeServiceClient) ClientStreamClose(ctx context.Context, in *ClientStreamClose_Request, opts ...grpc.CallOption) (*ClientStreamClose_Reply, error) {
	out := new(ClientStreamClose_Reply)
	err := c.cc.Invoke(ctx, "/berty.bridge.v1.BridgeService/ClientStreamClose", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeServiceClient) ClientStreamCloseAndRecv(ctx context.Context, in *ClientStreamCloseAndRecv_Request, opts ...grpc.CallOption) (*ClientStreamCloseAndRecv_Reply, error) {
	out := new(ClientStreamCloseAndRecv_Reply)
	err := c.cc.Invoke(ctx, "/berty.bridge.v1.BridgeService/ClientStreamCloseAndRecv", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BridgeServiceServer is the server API for BridgeService service.
type BridgeServiceServer interface {
	// ClientInvokeUnary invoke a unary method
	ClientInvokeUnary(context.Context, *ClientInvokeUnary_Request) (*ClientInvokeUnary_Reply, error)
	// CreateStream create a stream
	CreateClientStream(context.Context, *ClientCreateStream_Request) (*ClientCreateStream_Reply, error)
	// Send Message over the given stream
	ClientStreamSend(context.Context, *ClientStreamSend_Request) (*ClientStreamSend_Reply, error)
	// Recv message over the given stream
	ClientStreamRecv(context.Context, *ClientStreamRecv_Request) (*ClientStreamRecv_Reply, error)
	// Close the given stream (should not be used)
	ClientStreamClose(context.Context, *ClientStreamClose_Request) (*ClientStreamClose_Reply, error)
	// Close the writing end of a stream and return the next reply
	ClientStreamCloseAndRecv(context.Context, *ClientStreamCloseAndRecv_Request) (*ClientStreamCloseAndRecv_Reply, error)
}

// UnimplementedBridgeServiceServer can be embedded to have forward compatible implementations.
type UnimplementedBridgeServiceServer struct{}

func (*UnimplementedBridgeServiceServer) ClientInvokeUnary(ctx context.Context, req *ClientInvokeUnary_Request) (*ClientInvokeUnary_Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClientInvokeUnary not implemented")
}

func (*UnimplementedBridgeServiceServer) CreateClientStream(ctx context.Context, req *ClientCreateStream_Request) (*ClientCreateStream_Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateClientStream not implemented")
}

func (*UnimplementedBridgeServiceServer) ClientStreamSend(ctx context.Context, req *ClientStreamSend_Request) (*ClientStreamSend_Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClientStreamSend not implemented")
}

func (*UnimplementedBridgeServiceServer) ClientStreamRecv(ctx context.Context, req *ClientStreamRecv_Request) (*ClientStreamRecv_Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClientStreamRecv not implemented")
}

func (*UnimplementedBridgeServiceServer) ClientStreamClose(ctx context.Context, req *ClientStreamClose_Request) (*ClientStreamClose_Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClientStreamClose not implemented")
}

func (*UnimplementedBridgeServiceServer) ClientStreamCloseAndRecv(ctx context.Context, req *ClientStreamCloseAndRecv_Request) (*ClientStreamCloseAndRecv_Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClientStreamCloseAndRecv not implemented")
}

func RegisterBridgeServiceServer(s *grpc.Server, srv BridgeServiceServer) {
	s.RegisterService(&_BridgeService_serviceDesc, srv)
}

func _BridgeService_ClientInvokeUnary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientInvokeUnary_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeServiceServer).ClientInvokeUnary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.bridge.v1.BridgeService/ClientInvokeUnary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeServiceServer).ClientInvokeUnary(ctx, req.(*ClientInvokeUnary_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeService_CreateClientStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientCreateStream_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeServiceServer).CreateClientStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.bridge.v1.BridgeService/CreateClientStream",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeServiceServer).CreateClientStream(ctx, req.(*ClientCreateStream_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeService_ClientStreamSend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientStreamSend_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeServiceServer).ClientStreamSend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.bridge.v1.BridgeService/ClientStreamSend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeServiceServer).ClientStreamSend(ctx, req.(*ClientStreamSend_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeService_ClientStreamRecv_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientStreamRecv_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeServiceServer).ClientStreamRecv(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.bridge.v1.BridgeService/ClientStreamRecv",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeServiceServer).ClientStreamRecv(ctx, req.(*ClientStreamRecv_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeService_ClientStreamClose_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientStreamClose_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeServiceServer).ClientStreamClose(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.bridge.v1.BridgeService/ClientStreamClose",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeServiceServer).ClientStreamClose(ctx, req.(*ClientStreamClose_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeService_ClientStreamCloseAndRecv_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientStreamCloseAndRecv_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeServiceServer).ClientStreamCloseAndRecv(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.bridge.v1.BridgeService/ClientStreamCloseAndRecv",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeServiceServer).ClientStreamCloseAndRecv(ctx, req.(*ClientStreamCloseAndRecv_Request))
	}
	return interceptor(ctx, in, info, handler)
}

var _BridgeService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "berty.bridge.v1.BridgeService",
	HandlerType: (*BridgeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ClientInvokeUnary",
			Handler:    _BridgeService_ClientInvokeUnary_Handler,
		},
		{
			MethodName: "CreateClientStream",
			Handler:    _BridgeService_CreateClientStream_Handler,
		},
		{
			MethodName: "ClientStreamSend",
			Handler:    _BridgeService_ClientStreamSend_Handler,
		},
		{
			MethodName: "ClientStreamRecv",
			Handler:    _BridgeService_ClientStreamRecv_Handler,
		},
		{
			MethodName: "ClientStreamClose",
			Handler:    _BridgeService_ClientStreamClose_Handler,
		},
		{
			MethodName: "ClientStreamCloseAndRecv",
			Handler:    _BridgeService_ClientStreamCloseAndRecv_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bertybridge.proto",
}

func (m *ClientInvokeUnary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientInvokeUnary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientInvokeUnary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ClientInvokeUnary_Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientInvokeUnary_Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientInvokeUnary_Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Header) > 0 {
		for iNdEx := len(m.Header) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Header[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBertybridge(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintBertybridge(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x1a
	}
	if m.MethodDesc != nil {
		{
			size, err := m.MethodDesc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBertybridge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *ClientInvokeUnary_Reply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientInvokeUnary_Reply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientInvokeUnary_Reply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBertybridge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Trailer) > 0 {
		for iNdEx := len(m.Trailer) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Trailer[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBertybridge(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintBertybridge(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *ClientCreateStream) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientCreateStream) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientCreateStream) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ClientCreateStream_Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientCreateStream_Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientCreateStream_Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Header) > 0 {
		for iNdEx := len(m.Header) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Header[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBertybridge(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintBertybridge(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x1a
	}
	if m.MethodDesc != nil {
		{
			size, err := m.MethodDesc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBertybridge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *ClientCreateStream_Reply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientCreateStream_Reply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientCreateStream_Reply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBertybridge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Trailer) > 0 {
		for iNdEx := len(m.Trailer) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Trailer[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBertybridge(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.StreamId) > 0 {
		i -= len(m.StreamId)
		copy(dAtA[i:], m.StreamId)
		i = encodeVarintBertybridge(dAtA, i, uint64(len(m.StreamId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClientStreamSend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientStreamSend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientStreamSend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ClientStreamSend_Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientStreamSend_Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientStreamSend_Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintBertybridge(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StreamId) > 0 {
		i -= len(m.StreamId)
		copy(dAtA[i:], m.StreamId)
		i = encodeVarintBertybridge(dAtA, i, uint64(len(m.StreamId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClientStreamSend_Reply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientStreamSend_Reply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientStreamSend_Reply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBertybridge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Trailer) > 0 {
		for iNdEx := len(m.Trailer) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Trailer[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBertybridge(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.StreamId) > 0 {
		i -= len(m.StreamId)
		copy(dAtA[i:], m.StreamId)
		i = encodeVarintBertybridge(dAtA, i, uint64(len(m.StreamId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClientStreamRecv) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientStreamRecv) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientStreamRecv) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ClientStreamRecv_Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientStreamRecv_Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientStreamRecv_Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StreamId) > 0 {
		i -= len(m.StreamId)
		copy(dAtA[i:], m.StreamId)
		i = encodeVarintBertybridge(dAtA, i, uint64(len(m.StreamId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClientStreamRecv_Reply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientStreamRecv_Reply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientStreamRecv_Reply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBertybridge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Trailer) > 0 {
		for iNdEx := len(m.Trailer) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Trailer[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBertybridge(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintBertybridge(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StreamId) > 0 {
		i -= len(m.StreamId)
		copy(dAtA[i:], m.StreamId)
		i = encodeVarintBertybridge(dAtA, i, uint64(len(m.StreamId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClientStreamClose) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientStreamClose) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientStreamClose) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ClientStreamClose_Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientStreamClose_Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientStreamClose_Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StreamId) > 0 {
		i -= len(m.StreamId)
		copy(dAtA[i:], m.StreamId)
		i = encodeVarintBertybridge(dAtA, i, uint64(len(m.StreamId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClientStreamClose_Reply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientStreamClose_Reply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientStreamClose_Reply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBertybridge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Trailer) > 0 {
		for iNdEx := len(m.Trailer) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Trailer[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBertybridge(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.StreamId) > 0 {
		i -= len(m.StreamId)
		copy(dAtA[i:], m.StreamId)
		i = encodeVarintBertybridge(dAtA, i, uint64(len(m.StreamId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClientStreamCloseAndRecv) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientStreamCloseAndRecv) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientStreamCloseAndRecv) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ClientStreamCloseAndRecv_Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientStreamCloseAndRecv_Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientStreamCloseAndRecv_Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StreamId) > 0 {
		i -= len(m.StreamId)
		copy(dAtA[i:], m.StreamId)
		i = encodeVarintBertybridge(dAtA, i, uint64(len(m.StreamId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClientStreamCloseAndRecv_Reply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientStreamCloseAndRecv_Reply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientStreamCloseAndRecv_Reply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBertybridge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Trailer) > 0 {
		for iNdEx := len(m.Trailer) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Trailer[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBertybridge(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintBertybridge(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StreamId) > 0 {
		i -= len(m.StreamId)
		copy(dAtA[i:], m.StreamId)
		i = encodeVarintBertybridge(dAtA, i, uint64(len(m.StreamId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MethodDesc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MethodDesc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MethodDesc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsServerStream {
		i--
		if m.IsServerStream {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.IsClientStream {
		i--
		if m.IsClientStream {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBertybridge(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Metadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Values[iNdEx])
			copy(dAtA[i:], m.Values[iNdEx])
			i = encodeVarintBertybridge(dAtA, i, uint64(len(m.Values[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintBertybridge(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ErrorDetails != nil {
		{
			size, err := m.ErrorDetails.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBertybridge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintBertybridge(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ErrorCode != 0 {
		i = encodeVarintBertybridge(dAtA, i, uint64(m.ErrorCode))
		i--
		dAtA[i] = 0x10
	}
	if m.GrpcErrorCode != 0 {
		i = encodeVarintBertybridge(dAtA, i, uint64(m.GrpcErrorCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintBertybridge(dAtA []byte, offset int, v uint64) int {
	offset -= sovBertybridge(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}

func (m *ClientInvokeUnary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientInvokeUnary_Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MethodDesc != nil {
		l = m.MethodDesc.Size()
		n += 1 + l + sovBertybridge(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovBertybridge(uint64(l))
	}
	if len(m.Header) > 0 {
		for _, e := range m.Header {
			l = e.Size()
			n += 1 + l + sovBertybridge(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientInvokeUnary_Reply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovBertybridge(uint64(l))
	}
	if len(m.Trailer) > 0 {
		for _, e := range m.Trailer {
			l = e.Size()
			n += 1 + l + sovBertybridge(uint64(l))
		}
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovBertybridge(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientCreateStream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientCreateStream_Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MethodDesc != nil {
		l = m.MethodDesc.Size()
		n += 1 + l + sovBertybridge(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovBertybridge(uint64(l))
	}
	if len(m.Header) > 0 {
		for _, e := range m.Header {
			l = e.Size()
			n += 1 + l + sovBertybridge(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientCreateStream_Reply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StreamId)
	if l > 0 {
		n += 1 + l + sovBertybridge(uint64(l))
	}
	if len(m.Trailer) > 0 {
		for _, e := range m.Trailer {
			l = e.Size()
			n += 1 + l + sovBertybridge(uint64(l))
		}
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovBertybridge(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientStreamSend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientStreamSend_Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StreamId)
	if l > 0 {
		n += 1 + l + sovBertybridge(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovBertybridge(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientStreamSend_Reply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StreamId)
	if l > 0 {
		n += 1 + l + sovBertybridge(uint64(l))
	}
	if len(m.Trailer) > 0 {
		for _, e := range m.Trailer {
			l = e.Size()
			n += 1 + l + sovBertybridge(uint64(l))
		}
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovBertybridge(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientStreamRecv) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientStreamRecv_Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StreamId)
	if l > 0 {
		n += 1 + l + sovBertybridge(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientStreamRecv_Reply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StreamId)
	if l > 0 {
		n += 1 + l + sovBertybridge(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovBertybridge(uint64(l))
	}
	if len(m.Trailer) > 0 {
		for _, e := range m.Trailer {
			l = e.Size()
			n += 1 + l + sovBertybridge(uint64(l))
		}
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovBertybridge(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientStreamClose) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientStreamClose_Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StreamId)
	if l > 0 {
		n += 1 + l + sovBertybridge(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientStreamClose_Reply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StreamId)
	if l > 0 {
		n += 1 + l + sovBertybridge(uint64(l))
	}
	if len(m.Trailer) > 0 {
		for _, e := range m.Trailer {
			l = e.Size()
			n += 1 + l + sovBertybridge(uint64(l))
		}
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovBertybridge(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientStreamCloseAndRecv) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientStreamCloseAndRecv_Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StreamId)
	if l > 0 {
		n += 1 + l + sovBertybridge(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientStreamCloseAndRecv_Reply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StreamId)
	if l > 0 {
		n += 1 + l + sovBertybridge(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovBertybridge(uint64(l))
	}
	if len(m.Trailer) > 0 {
		for _, e := range m.Trailer {
			l = e.Size()
			n += 1 + l + sovBertybridge(uint64(l))
		}
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovBertybridge(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MethodDesc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBertybridge(uint64(l))
	}
	if m.IsClientStream {
		n += 2
	}
	if m.IsServerStream {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Metadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovBertybridge(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovBertybridge(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GrpcErrorCode != 0 {
		n += 1 + sovBertybridge(uint64(m.GrpcErrorCode))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovBertybridge(uint64(m.ErrorCode))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovBertybridge(uint64(l))
	}
	if m.ErrorDetails != nil {
		l = m.ErrorDetails.Size()
		n += 1 + l + sovBertybridge(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBertybridge(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}

func sozBertybridge(x uint64) (n int) {
	return sovBertybridge(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}

func (m *ClientInvokeUnary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBertybridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientInvokeUnary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientInvokeUnary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBertybridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBertybridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *ClientInvokeUnary_Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBertybridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MethodDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MethodDesc == nil {
				m.MethodDesc = &MethodDesc{}
			}
			if err := m.MethodDesc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Header = append(m.Header, &Metadata{})
			if err := m.Header[len(m.Header)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBertybridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBertybridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *ClientInvokeUnary_Reply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBertybridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trailer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trailer = append(m.Trailer, &Metadata{})
			if err := m.Trailer[len(m.Trailer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBertybridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBertybridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *ClientCreateStream) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBertybridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientCreateStream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientCreateStream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBertybridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBertybridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *ClientCreateStream_Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBertybridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MethodDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MethodDesc == nil {
				m.MethodDesc = &MethodDesc{}
			}
			if err := m.MethodDesc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Header = append(m.Header, &Metadata{})
			if err := m.Header[len(m.Header)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBertybridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBertybridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *ClientCreateStream_Reply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBertybridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trailer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trailer = append(m.Trailer, &Metadata{})
			if err := m.Trailer[len(m.Trailer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBertybridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBertybridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *ClientStreamSend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBertybridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientStreamSend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientStreamSend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBertybridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBertybridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *ClientStreamSend_Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBertybridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBertybridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBertybridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *ClientStreamSend_Reply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBertybridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trailer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trailer = append(m.Trailer, &Metadata{})
			if err := m.Trailer[len(m.Trailer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBertybridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBertybridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *ClientStreamRecv) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBertybridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientStreamRecv: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientStreamRecv: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBertybridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBertybridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *ClientStreamRecv_Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBertybridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBertybridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBertybridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *ClientStreamRecv_Reply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBertybridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trailer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trailer = append(m.Trailer, &Metadata{})
			if err := m.Trailer[len(m.Trailer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBertybridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBertybridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *ClientStreamClose) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBertybridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientStreamClose: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientStreamClose: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBertybridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBertybridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *ClientStreamClose_Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBertybridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBertybridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBertybridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *ClientStreamClose_Reply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBertybridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trailer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trailer = append(m.Trailer, &Metadata{})
			if err := m.Trailer[len(m.Trailer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBertybridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBertybridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *ClientStreamCloseAndRecv) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBertybridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientStreamCloseAndRecv: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientStreamCloseAndRecv: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBertybridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBertybridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *ClientStreamCloseAndRecv_Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBertybridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBertybridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBertybridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *ClientStreamCloseAndRecv_Reply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBertybridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trailer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trailer = append(m.Trailer, &Metadata{})
			if err := m.Trailer[len(m.Trailer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBertybridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBertybridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *MethodDesc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBertybridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MethodDesc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MethodDesc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsClientStream", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsClientStream = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsServerStream", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsServerStream = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBertybridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBertybridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *Metadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBertybridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBertybridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBertybridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBertybridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrpcErrorCode", wireType)
			}
			m.GrpcErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GrpcErrorCode |= GRPCErrCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= errcode.ErrCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBertybridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBertybridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ErrorDetails == nil {
				m.ErrorDetails = &errcode.ErrDetails{}
			}
			if err := m.ErrorDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBertybridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBertybridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func skipBertybridge(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBertybridge
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBertybridge
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBertybridge
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBertybridge
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBertybridge
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBertybridge        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBertybridge          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBertybridge = fmt.Errorf("proto: unexpected end of group")
)
