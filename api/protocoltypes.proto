syntax = "proto3";

package berty.protocol.v1;

import "gogoproto/gogo.proto";
import "pushtypes.proto";

option go_package = "berty.tech/berty/go/pkg/protocoltypes";

option (gogoproto.goproto_enum_prefix_all) = false;
option (gogoproto.marshaler_all) = true;
option (gogoproto.unmarshaler_all) = true;
option (gogoproto.sizer_all) = true;

// ProtocolService is the top-level API to manage an instance of the Berty Protocol.
// Each Berty Protocol Instance is considered as a Berty device and is associated with a Berty user.
service ProtocolService {
  // InstanceExportData exports instance data
  rpc InstanceExportData (InstanceExportData.Request) returns (stream InstanceExportData.Reply);

  // InstanceGetConfiguration gets current configuration of this protocol instance
  rpc InstanceGetConfiguration (InstanceGetConfiguration.Request) returns (InstanceGetConfiguration.Reply);

  // ContactRequestReference retrieves the information required to create a reference (ie. included in a shareable link) to the current account
  rpc ContactRequestReference (ContactRequestReference.Request) returns (ContactRequestReference.Reply);

  // ContactRequestDisable disables incoming contact requests
  rpc ContactRequestDisable (ContactRequestDisable.Request) returns (ContactRequestDisable.Reply);

  // ContactRequestEnable enables incoming contact requests
  rpc ContactRequestEnable (ContactRequestEnable.Request) returns (ContactRequestEnable.Reply);

  // ContactRequestResetReference changes the contact request reference
  rpc ContactRequestResetReference (ContactRequestResetReference.Request) returns (ContactRequestResetReference.Reply);

  // ContactRequestSend attempt to send a contact request
  rpc ContactRequestSend (ContactRequestSend.Request) returns (ContactRequestSend.Reply);

  // ContactRequestAccept accepts a contact request
  rpc ContactRequestAccept (ContactRequestAccept.Request) returns (ContactRequestAccept.Reply);

  // ContactRequestDiscard ignores a contact request, without informing the other user
  rpc ContactRequestDiscard (ContactRequestDiscard.Request) returns (ContactRequestDiscard.Reply);

  // ContactBlock blocks a contact from sending requests
  rpc ContactBlock (ContactBlock.Request) returns (ContactBlock.Reply);

  // ContactUnblock unblocks a contact from sending requests
  rpc ContactUnblock (ContactUnblock.Request) returns (ContactUnblock.Reply);

  // ContactAliasKeySend send an alias key to a contact, the contact will be able to assert that your account is being present on a multi-member group
  rpc ContactAliasKeySend (ContactAliasKeySend.Request) returns (ContactAliasKeySend.Reply);

  // MultiMemberGroupCreate creates a new multi-member group
  rpc MultiMemberGroupCreate (MultiMemberGroupCreate.Request) returns (MultiMemberGroupCreate.Reply);

  // MultiMemberGroupJoin joins a multi-member group
  rpc MultiMemberGroupJoin (MultiMemberGroupJoin.Request) returns (MultiMemberGroupJoin.Reply);

  // MultiMemberGroupLeave leaves a multi-member group
  rpc MultiMemberGroupLeave (MultiMemberGroupLeave.Request) returns (MultiMemberGroupLeave.Reply);

  // MultiMemberGroupAliasResolverDisclose discloses your alias resolver key
  rpc MultiMemberGroupAliasResolverDisclose (MultiMemberGroupAliasResolverDisclose.Request) returns (MultiMemberGroupAliasResolverDisclose.Reply);

  // MultiMemberGroupAdminRoleGrant grants an admin role to a group member
  rpc MultiMemberGroupAdminRoleGrant (MultiMemberGroupAdminRoleGrant.Request) returns (MultiMemberGroupAdminRoleGrant.Reply);

  // MultiMemberGroupInvitationCreate creates an invitation to a multi-member group
  rpc MultiMemberGroupInvitationCreate (MultiMemberGroupInvitationCreate.Request) returns (MultiMemberGroupInvitationCreate.Reply);

  // AppMetadataSend adds an app event to the metadata store, the message is encrypted using a symmetric key and readable by future group members
  rpc AppMetadataSend (AppMetadataSend.Request) returns (AppMetadataSend.Reply);

  // AppMessageSend adds an app event to the message store, the message is encrypted using a derived key and readable by current group members
  rpc AppMessageSend (AppMessageSend.Request) returns (AppMessageSend.Reply);

  // GroupMetadataList replays previous and subscribes to new metadata events from the group
  rpc GroupMetadataList (GroupMetadataList.Request) returns (stream GroupMetadataEvent);

  // GroupMessageList replays previous and subscribes to new message events from the group
  rpc GroupMessageList (GroupMessageList.Request) returns (stream GroupMessageEvent);

  // GroupInfo retrieves information about a group
  rpc GroupInfo (GroupInfo.Request) returns (GroupInfo.Reply);

  // ActivateGroup explicitly opens a group
  rpc ActivateGroup (ActivateGroup.Request) returns (ActivateGroup.Reply);

  // DeactivateGroup closes a group
  rpc DeactivateGroup (DeactivateGroup.Request) returns (DeactivateGroup.Reply);

  // Monitor Group events
  rpc MonitorGroup (MonitorGroup.Request) returns (stream MonitorGroup.Reply);

  rpc DebugListGroups (DebugListGroups.Request) returns (stream DebugListGroups.Reply);

  rpc DebugInspectGroupStore (DebugInspectGroupStore.Request) returns (stream DebugInspectGroupStore.Reply);

  rpc DebugGroup (DebugGroup.Request) returns (DebugGroup.Reply);

  rpc DebugAuthServiceSetToken(DebugAuthServiceSetToken.Request) returns (DebugAuthServiceSetToken.Reply);

  rpc SystemInfo (SystemInfo.Request) returns (SystemInfo.Reply);

  // AuthServiceInitFlow Initialize an authentication flow
  rpc AuthServiceInitFlow (AuthServiceInitFlow.Request) returns (AuthServiceInitFlow.Reply);

  // AuthServiceCompleteFlow Completes an authentication flow
  rpc AuthServiceCompleteFlow (AuthServiceCompleteFlow.Request) returns (AuthServiceCompleteFlow.Reply);

  // ServicesTokenList Retrieves the list of services tokens
  rpc ServicesTokenList (ServicesTokenList.Request) returns (stream ServicesTokenList.Reply);

  // ReplicationServiceRegisterGroup Asks a replication service to distribute a group contents
  rpc ReplicationServiceRegisterGroup (ReplicationServiceRegisterGroup.Request) returns (ReplicationServiceRegisterGroup.Reply);

  // PeerList returns a list of P2P peers
  rpc PeerList(PeerList.Request) returns (PeerList.Reply);

  // AttachmentPrepare ...
  rpc AttachmentPrepare(stream AttachmentPrepare.Request) returns (AttachmentPrepare.Reply);

  // AttachmentRetrieve returns an attachment data
  rpc AttachmentRetrieve(AttachmentRetrieve.Request) returns (stream AttachmentRetrieve.Reply);

  // PushReceive handles a push payload, decrypts it if possible
  rpc PushReceive(PushReceive.Request) returns (PushReceive.Reply);

  // PushSend sends a push payload to a specified list of group members
  rpc PushSend(PushSend.Request) returns (PushSend.Reply);

  // PushShareToken sends push tokens of own devices to a group
  rpc PushShareToken(PushShareToken.Request) returns (PushShareToken.Reply);

  // PushSetDeviceToken registers a push token for the current device
  rpc PushSetDeviceToken(PushSetDeviceToken.Request) returns (PushSetDeviceToken.Reply);

  // PushSetServer registers a push server for the current device
  rpc PushSetServer(PushSetServer.Request) returns (PushSetServer.Reply);
}


enum GroupType {
  // GroupTypeUndefined indicates that the value has not been set. For example, happens if group is replicated.
  GroupTypeUndefined = 0;

  // GroupTypeAccount is the group managing an account, available to all its devices.
  GroupTypeAccount = 1;

  // GroupTypeContact is the group created between two accounts, available to all their devices.
  GroupTypeContact = 2;

  // GroupTypeMultiMember is a group containing an undefined number of members.
  GroupTypeMultiMember = 3;

  // Following group types have not been defined, first is a group with
  // only approved writers, second is public group with anyone allowed to
  // write, in both cases full history is available to new members.
  //
  // GroupTypeChannel = 4;
  // GroupTypePublic = 5;
}

enum EventType {
  // EventTypeUndefined indicates that the value has not been set. Should not happen.
  EventTypeUndefined = 0;

  // EventTypeGroupMemberDeviceAdded indicates the payload includes that a member has added their device to the group
  EventTypeGroupMemberDeviceAdded = 1;

  // EventTypeGroupDeviceSecretAdded indicates the payload includes that a member has sent their device secret to another member
  EventTypeGroupDeviceSecretAdded = 2;

  // EventTypeGroupAdditionalRendezvousSeedAdded adds a new rendezvous seed to a group
  // Might be implemented later, could be useful for replication services
  // EventTypeGroupAdditionalRendezvousSeedAdded = 3;

  // EventTypeGroupAdditionalRendezvousSeedRemoved removes a rendezvous seed from a group
  // Might be implemented later, could be useful for replication services
  // EventTypeGroupAdditionalRendezvousSeedRemoved = 4;

  // EventTypeAccountGroupJoined indicates the payload includes that the account has joined a group
  EventTypeAccountGroupJoined = 101;

  // EventTypeAccountGroupLeft indicates the payload includes that the account has left a group
  EventTypeAccountGroupLeft = 102;

  // EventTypeAccountContactRequestDisabled indicates the payload includes that the account has disabled incoming contact requests
  EventTypeAccountContactRequestDisabled = 103;

  // EventTypeAccountContactRequestEnabled indicates the payload includes that the account has enabled incoming contact requests
  EventTypeAccountContactRequestEnabled = 104;

  // EventTypeAccountContactRequestReferenceReset indicates the payload includes that the account has a new contact request rendezvous seed
  EventTypeAccountContactRequestReferenceReset = 105;

  // EventTypeAccountContactRequestEnqueued indicates the payload includes that the account will attempt to send a new contact request
  EventTypeAccountContactRequestOutgoingEnqueued = 106;

  // EventTypeAccountContactRequestSent indicates the payload includes that the account has sent a contact request
  EventTypeAccountContactRequestOutgoingSent = 107;

  // EventTypeAccountContactRequestReceived indicates the payload includes that the account has received a contact request
  EventTypeAccountContactRequestIncomingReceived = 108;

  // EventTypeAccountContactRequestIncomingDiscarded indicates the payload includes that the account has ignored a contact request
  EventTypeAccountContactRequestIncomingDiscarded = 109;

  // EventTypeAccountContactRequestAccepted indicates the payload includes that the account has accepted a contact request
  EventTypeAccountContactRequestIncomingAccepted = 110;

  // EventTypeAccountContactBlocked indicates the payload includes that the account has blocked a contact
  EventTypeAccountContactBlocked = 111;

  // EventTypeAccountContactUnblocked indicates the payload includes that the account has unblocked a contact
  EventTypeAccountContactUnblocked = 112;

  // EventTypeContactAliasKeyAdded indicates the payload includes that the contact group has received an alias key
  EventTypeContactAliasKeyAdded = 201;

  // EventTypeMultiMemberGroupAliasResolverAdded indicates the payload includes that a member of the group sent their alias proof
  EventTypeMultiMemberGroupAliasResolverAdded = 301;

  // EventTypeMultiMemberGroupInitialMemberAnnounced indicates the payload includes that a member has authenticated themselves as the group owner
  EventTypeMultiMemberGroupInitialMemberAnnounced = 302;

  // EventTypeMultiMemberGroupAdminRoleGranted indicates the payload includes that an admin of the group granted another member as an admin
  EventTypeMultiMemberGroupAdminRoleGranted = 303;

  // EventTypeAccountServiceTokenAdded indicates that a new service provider has been registered for this account
  EventTypeAccountServiceTokenAdded = 401;

  // EventTypeAccountServiceTokenRemoved indicates that a service provider is not available anymore
  EventTypeAccountServiceTokenRemoved = 402;

  // EventTypeGroupReplicating indicates that the group has been registered for replication on a server
  EventTypeGroupReplicating = 403;

  // EventTypePushMemberTokenUpdate
  EventTypePushMemberTokenUpdate = 404;

  // EventTypePushDeviceTokenRegistered
  EventTypePushDeviceTokenRegistered = 405;

  // EventTypePushDeviceServerRegistered
  EventTypePushDeviceServerRegistered = 406;

  // EventTypeGroupMetadataPayloadSent indicates the payload includes an app specific event, unlike messages stored on the message store it is encrypted using a static key
  EventTypeGroupMetadataPayloadSent = 1001;
}

// Account describes all the secrets that identifies an Account
message Account {
  // group specifies which group is used to manage the account
  Group group = 1;

  // account_private_key, private part is used to signs handshake, signs device, create contacts group keys via ECDH -- public part is used to have a shareable identity
  bytes account_private_key = 2;

  // alias_private_key, private part is use to derive group members private keys, signs alias proofs, public part can be shared to contacts to prove identity
  bytes alias_private_key = 3;

  // public_rendezvous_seed, rendezvous seed used for direct communication
  bytes public_rendezvous_seed = 4;
}

// Group define a group and is enough to invite someone to it
message Group {
  // public_key is the identifier of the group, it signs the group secret and the initial member of a multi-member group
  bytes public_key = 1;

  // secret is the symmetric secret of the group, which is used to encrypt the metadata
  bytes secret = 2;

  // secret_sig is the signature of the secret used to ensure the validity of the group
  bytes secret_sig = 3;

  // group_type specifies the type of the group, used to determine how device secrets are generated
  GroupType group_type = 4;

  // sign_pub is the signature public key used to verify entries, not required when secret and secret_sig are provided
  bytes sign_pub = 5;

  // link_key is the secret key used to exchange group updates and links to attachments, useful for replication services
  bytes link_key = 6;

  // link_key_sig is the signature of the link_key using the group private key
  bytes link_key_sig = 7;
}

message GroupHeadsExport {
  // public_key is the identifier of the group, it signs the group secret and the initial member of a multi-member group
  bytes public_key = 1;

  // sign_pub is the signature public key used to verify entries
  bytes sign_pub = 2;

  // metadata_heads_cids are the heads of the metadata store that should be restored from an export
  repeated bytes metadata_heads_cids = 3 [(gogoproto.customname) = "MetadataHeadsCIDs"];

  // messages_heads_cids are the heads of the metadata store that should be restored from an export
  repeated bytes messages_heads_cids = 4 [(gogoproto.customname) = "MessagesHeadsCIDs"];

  // link_key
  bytes link_key = 5;
}

// GroupMetadata is used in GroupEnvelope and only readable by invited group members
message GroupMetadata {
  // event_type defines which event type is used
  EventType event_type = 1;

  // the serialization depends on event_type, event is symmetrically encrypted
  bytes payload = 2;

  // sig is the signature of the payload, it depends on the event_type for the used key
  bytes sig = 3;

  // protocol_metadata is protocol layer data
  ProtocolMetadata protocol_metadata = 4;
}

// GroupEnvelope is a publicly exposed structure containing a group metadata event
message GroupEnvelope {
  // nonce is used to encrypt the message
  bytes nonce = 1;

  // event is encrypted using a symmetric key shared among group members
  bytes event = 2;

  // encrypted_attachment_cids is a list of attachment CIDs encrypted specifically for replication services
  repeated bytes encrypted_attachment_cids = 3  [(gogoproto.customname) = "EncryptedAttachmentCIDs"];
}

// MessageHeaders is used in MessageEnvelope and only readable by invited group members
message MessageHeaders {
  // counter is the current counter value for the specified device
  uint64 counter = 1;

  // device_pk is the public key of the device sending the message
  bytes device_pk = 2 [(gogoproto.customname) = "DevicePK"];

  // sig is the signature of the encrypted message using the device's private key
  bytes sig = 3;

  // metadata allow to pass custom informations
  map<string, string> metadata = 4;
}

message ProtocolMetadata {
  // attachments_secrets is a list of secret keys used retrieve attachments
  repeated bytes attachments_secrets = 1;
}

// EncryptedMessage is used in MessageEnvelope and only readable by groups members that joined before the message was sent
message EncryptedMessage {
  // plaintext is the app layer data
  bytes plaintext = 1;

  // protocol_metadata is protocol layer data
  ProtocolMetadata protocol_metadata = 2;
}

// MessageEnvelope is a publicly exposed structure containing a group secure message
message MessageEnvelope {
  // message_headers is an encrypted serialization using a symmetric key of a MessageHeaders message
  bytes message_headers = 1;

  // message is an encrypted message, only readable by group members who previously received the appropriate chain key
  bytes message = 2;

  // nonce is a nonce for message headers
  bytes nonce = 3;

  // encrypted_attachment_cids is a list of attachment CIDs encrypted specifically for replication services
  repeated bytes encrypted_attachment_cids = 4 [(gogoproto.customname) = "EncryptedAttachmentCIDs"];
}

// ***************************************************************************
// Group event types
// ***************************************************************************

// EventContext adds context (its id, its parents and its attachments) to an event
message EventContext {
  // id is the CID of the underlying OrbitDB event
  bytes id = 1 [(gogoproto.customname) = "ID"];

  // id are the the CIDs of the underlying parents of the OrbitDB event
  repeated bytes parent_ids = 2 [(gogoproto.customname) = "ParentIDs"];

  // group_pk receiving the event
  bytes group_pk = 3[(gogoproto.customname) = "GroupPK"];

  // attachment_cids is a list of attachment that can be retrieved
  repeated bytes attachment_cids = 4 [(gogoproto.customname) = "AttachmentCIDs"];
}

// AppMetadata is an app defined message, accessible to future group members
message AppMetadata {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1 [(gogoproto.customname) = "DevicePK"];

  // message is the payload
  bytes message = 2;
}

// ContactAddAliasKey is an event type where ones shares their alias public key
message ContactAddAliasKey {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1 [(gogoproto.customname) = "DevicePK"];

  // alias_pk is the alias key which will be used to verify a contact identity
  bytes alias_pk = 2 [(gogoproto.customname) = "AliasPK"];
}

// GroupAddMemberDevice is an event which indicates to a group a new device (and eventually a new member) is joining it
// When added on AccountGroup, this event should be followed by appropriate GroupAddMemberDevice and GroupAddDeviceSecret events
message GroupAddMemberDevice {
  // member_pk is the member sending the event
  bytes member_pk = 1 [(gogoproto.customname) = "MemberPK"];

  // device_pk is the device sending the event, signs the message
  bytes device_pk = 2 [(gogoproto.customname) = "DevicePK"];

  // member_sig is used to prove the ownership of the member pk
  bytes member_sig = 3; // TODO: signature of what ??? ensure it can't be replayed
}

// DeviceSecret is encrypted for a specific member of the group
message DeviceSecret {
  // chain_key is the current value of the chain key of the group device
  bytes chain_key = 1;

  // counter is the current value of the counter of the group device
  uint64 counter = 2;
}

// GroupAddDeviceSecret is an event which indicates to a group member a device secret
message GroupAddDeviceSecret {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1 [(gogoproto.customname) = "DevicePK"];

  // dest_member_pk is the member who should receive the secret
  bytes dest_member_pk = 2 [(gogoproto.customname) = "DestMemberPK"];

  // payload is the serialization of Payload encrypted for the specified member
  bytes payload = 3;
}

// MultiMemberGroupAddAliasResolver indicates that a group member want to disclose their presence in the group to their contacts
message MultiMemberGroupAddAliasResolver {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1 [(gogoproto.customname) = "DevicePK"];

  // alias_resolver allows contact of an account to resolve the real identity behind an alias (Multi-Member Group Member)
  // Generated by both contacts and account independently using: hmac(aliasPK, GroupID)
  bytes alias_resolver = 2;

  // alias_proof ensures that the associated alias_resolver has been issued by the right account
  // Generated using aliasSKSig(GroupID)
  bytes alias_proof = 3;
}

// MultiMemberGrantAdminRole indicates that a group admin allows another group member to act as an admin
message MultiMemberGrantAdminRole {
  // device_pk is the device sending the event, signs the message, must be the device of an admin of the group
  bytes device_pk = 1 [(gogoproto.customname) = "DevicePK"];

  // grantee_member_pk is the member public key of the member granted of the admin role
  bytes grantee_member_pk = 2 [(gogoproto.customname) = "GranteeMemberPK"];
}

// MultiMemberInitialMember indicates that a member is the group creator, this event is signed using the group ID private key
message MultiMemberInitialMember {
  // member_pk is the public key of the member who is the group creator
  bytes member_pk = 1 [(gogoproto.customname) = "MemberPK"];
}

// GroupAddAdditionalRendezvousSeed indicates that an additional rendezvous point should be used for data synchronization
message GroupAddAdditionalRendezvousSeed {
  // device_pk is the device sending the event, signs the message, must be the device of an admin of the group
  bytes device_pk = 1 [(gogoproto.customname) = "DevicePK"];

  // seed is the additional rendezvous point seed which should be used
  bytes seed = 2;
}

// GroupRemoveAdditionalRendezvousSeed indicates that a previously added rendezvous point should be removed
message GroupRemoveAdditionalRendezvousSeed {
  // device_pk is the device sending the event, signs the message, must be the device of an admin of the group
  bytes device_pk = 1 [(gogoproto.customname) = "DevicePK"];

  // seed is the additional rendezvous point seed which should be removed
  bytes seed = 2;
}

// AccountGroupJoined indicates that the account is now part of a new group
message AccountGroupJoined {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1 [(gogoproto.customname) = "DevicePK"];

  // group describe the joined group
  Group group = 2;
}

// AccountGroupJoined indicates that the account has left a group
message AccountGroupLeft {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1 [(gogoproto.customname) = "DevicePK"];

  // group_pk references the group left
  bytes group_pk = 2 [(gogoproto.customname) = "GroupPK"];
}

// AccountContactRequestDisabled indicates that the account should not be advertised on a public rendezvous point
message AccountContactRequestDisabled {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1 [(gogoproto.customname) = "DevicePK"];
}

// AccountContactRequestDisabled indicates that the account should be advertised on a public rendezvous point
message AccountContactRequestEnabled {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1 [(gogoproto.customname) = "DevicePK"];
}

// AccountContactRequestDisabled indicates that the account should be advertised on different public rendezvous points
message AccountContactRequestReferenceReset {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1 [(gogoproto.customname) = "DevicePK"];

  // public_rendezvous_seed is the new rendezvous point seed
  bytes public_rendezvous_seed = 2;
}

// This event should be followed by an AccountGroupJoined event
// This event should be followed by a GroupAddMemberDevice event within the AccountGroup
// This event should be followed by a GroupAddDeviceSecret event within the AccountGroup
// AccountContactRequestEnqueued indicates that the account will attempt to send a contact request when a matching peer is discovered
message AccountContactRequestEnqueued {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1 [(gogoproto.customname) = "DevicePK"];

  // group_pk is the 1to1 group with the requested user
  bytes group_pk = 2 [(gogoproto.customname) = "GroupPK"];

  // contact is a message describing how to connect to the other account
  ShareableContact contact = 3;

  // own_metadata is the identifying metadata that will be shared to the other account
  bytes own_metadata = 4;
}

// AccountContactRequestSent indicates that the account has sent a contact request
message AccountContactRequestSent {
  // device_pk is the device sending the account event, signs the message
  bytes device_pk = 1 [(gogoproto.customname) = "DevicePK"];

  // contact_pk is the contacted account
  bytes contact_pk = 2 [(gogoproto.customname) = "ContactPK"];
}

// AccountContactRequestReceived indicates that the account has received a new contact request
message AccountContactRequestReceived {
  // device_pk is the device sending the account event (which received the contact request), signs the message
  bytes device_pk = 1 [(gogoproto.customname) = "DevicePK"];

  // contact_pk is the account sending the request
  bytes contact_pk = 2 [(gogoproto.customname) = "ContactPK"];

  // TODO: is this necessary?
  // contact_rendezvous_seed is the rendezvous seed of the contact sending the request
  bytes contact_rendezvous_seed = 3;

  // TODO: is this necessary?
  // contact_metadata is the metadata specific to the app to identify the contact for the request
  bytes contact_metadata = 4;
}

// AccountContactRequestDiscarded indicates that a contact request has been refused
message AccountContactRequestDiscarded {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1 [(gogoproto.customname) = "DevicePK"];

  // contact_pk is the contact whom request is refused
  bytes contact_pk = 2 [(gogoproto.customname) = "ContactPK"];
}

// This event should be followed by an AccountGroupJoined event
// This event should be followed by GroupAddMemberDevice and GroupAddDeviceSecret events within the AccountGroup
// AccountContactRequestAccepted indicates that a contact request has been accepted
message AccountContactRequestAccepted {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1 [(gogoproto.customname) = "DevicePK"];

  // contact_pk is the contact whom request is accepted
  bytes contact_pk = 2 [(gogoproto.customname) = "ContactPK"];

  // group_pk is the 1to1 group with the requester user
  bytes group_pk = 3 [(gogoproto.customname) = "GroupPK"];
}

// AccountContactBlocked indicates that a contact is blocked
message AccountContactBlocked {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1 [(gogoproto.customname) = "DevicePK"];

  // contact_pk is the contact blocked
  bytes contact_pk = 2 [(gogoproto.customname) = "ContactPK"];
}

// AccountContactUnblocked indicates that a contact is unblocked
message AccountContactUnblocked {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1 [(gogoproto.customname) = "DevicePK"];

  // contact_pk is the contact unblocked
  bytes contact_pk = 2 [(gogoproto.customname) = "ContactPK"];
}

// AccountServiceTokenAdded indicates a token has been added to the account
message AccountServiceTokenAdded {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1 [(gogoproto.customname) = "DevicePK"];

  ServiceToken service_token = 2;
}

// AccountServiceTokenRemoved indicates a token has removed
message AccountServiceTokenRemoved {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1 [(gogoproto.customname) = "DevicePK"];

  string token_id = 2 [(gogoproto.customname) = "TokenID"];
}

message GroupReplicating {
  // device_pk is the device sending the event, signs the message
  bytes device_pk = 1 [(gogoproto.customname) = "DevicePK"];

  // authentication_url indicates which server has been used for authentication
  string authentication_url = 2 [(gogoproto.customname) = "AuthenticationURL"];

  // replication_server indicates which server will be used for replication
  string replication_server = 3;
}

// ***************************************************************************
//  RPC methods inputs and outputs
// ***************************************************************************

message InstanceExportData {
  message Request {}
  message Reply {
    bytes exported_data = 1;
  }
}

message InstanceGetConfiguration {
  enum SettingState {
    Unknown = 0;
    Enabled = 1;
    Disabled = 2;
    Unavailable = 3;
  }
  message Request {}
  message Reply {
    // account_pk is the public key of the current account
    bytes account_pk = 1 [(gogoproto.customname) = "AccountPK"];

    // device_pk is the public key of the current device
    bytes device_pk = 2 [(gogoproto.customname) = "DevicePK"];

    // account_group_pk is the public key of the account group
    bytes account_group_pk = 3 [(gogoproto.customname) = "AccountGroupPK"];

    string peer_id = 4 [(gogoproto.customname) = "PeerID"];
    repeated string listeners = 5;
    SettingState ble_enabled = 6;
    SettingState wifi_p2p_enabled = 7; // MultiPeerConnectivity for Darwin and Nearby for Android
    SettingState mdns_enabled = 8;
    SettingState relay_enabled = 9;
    PushServiceReceiver device_push_token = 10;
    PushServer device_push_server = 11;
  }
}

message ContactRequestReference {
  message Request {}
  message Reply {
    // public_rendezvous_seed is the rendezvous seed used by the current account
    bytes public_rendezvous_seed = 1;

    // enabled indicates if incoming contact requests are enabled
    bool enabled = 2;
  }
}

message ContactRequestDisable {
  message Request {}
  message Reply {}
}

message ContactRequestEnable {
  message Request {}
  message Reply {
    // public_rendezvous_seed is the rendezvous seed used by the current account
    bytes public_rendezvous_seed = 1;
  }
}

message ContactRequestResetReference {
  message Request {}
  message Reply {
    // public_rendezvous_seed is the rendezvous seed used by the current account
    bytes public_rendezvous_seed = 1;
  }
}

message ContactRequestSend {
  message Request {
    // contact is a message describing how to connect to the other account
    ShareableContact contact = 1;

    // own_metadata is the identifying metadata that will be shared to the other account
    bytes own_metadata = 2;
  }
  message Reply {}
}

message ContactRequestAccept {
  message Request {
    // contact_pk is the identifier of the contact to accept the request from
    bytes contact_pk = 1 [(gogoproto.customname) = "ContactPK"];
  }

  message Reply {}
}

message ContactRequestDiscard {
  message Request {
    // contact_pk is the identifier of the contact to ignore the request from
    bytes contact_pk = 1 [(gogoproto.customname) = "ContactPK"];
  }

  message Reply {}
}

message ContactBlock {
  message Request {
    // contact_pk is the identifier of the contact to block
    bytes contact_pk = 1 [(gogoproto.customname) = "ContactPK"];
  }

  message Reply {}
}

message ContactUnblock {
  message Request {
    // contact_pk is the identifier of the contact to unblock
    bytes contact_pk = 1 [(gogoproto.customname) = "ContactPK"];
  }

  message Reply {}
}

message ContactAliasKeySend {
  message Request {
    // contact_pk is the identifier of the contact to send the alias public key to
    bytes group_pk = 1 [(gogoproto.customname) = "GroupPK"];
  }

  message Reply {}
}

message MultiMemberGroupCreate {
  message Request {}
  message Reply {
    // group_pk is the identifier of the newly created group
    bytes group_pk = 1 [(gogoproto.customname) = "GroupPK"];
  }
}

message MultiMemberGroupJoin {
  message Request {
    // group is the information of the group to join
    Group group = 1;
  }

  message Reply {}
}

message MultiMemberGroupLeave {
  message Request {
    bytes group_pk = 1 [(gogoproto.customname) = "GroupPK"];
  }

  message Reply {}
}

message MultiMemberGroupAliasResolverDisclose {
  message Request {
    // group_pk is the identifier of the group
    bytes group_pk = 1 [(gogoproto.customname) = "GroupPK"];
  }

  message Reply {}
}

message MultiMemberGroupAdminRoleGrant {
  message Request {
    // group_pk is the identifier of the group
    bytes group_pk = 1 [(gogoproto.customname) = "GroupPK"];

    // member_pk is the identifier of the member which will be granted the admin role
    bytes member_pk = 2 [(gogoproto.customname) = "MemberPK"];
  }

  message Reply {}
}

message MultiMemberGroupInvitationCreate {
  message Request {
    // group_pk is the identifier of the group
    bytes group_pk = 1 [(gogoproto.customname) = "GroupPK"];
  }

  message Reply {
    // group is the invitation to the group
    Group group = 1;
  }
}

message AppMetadataSend {
  message Request {
    // group_pk is the identifier of the group
    bytes group_pk = 1 [(gogoproto.customname) = "GroupPK"];

    // payload is the payload to send
    bytes payload = 2;

    // attachment_cids is a list of attachment cids
    repeated bytes attachment_cids = 3 [(gogoproto.customname) = "AttachmentCIDs"];
  }

  message Reply {
    bytes cid = 1 [(gogoproto.customname) = "CID"];
  }
}

message AppMessageSend {
  message Request {
    // group_pk is the identifier of the group
    bytes group_pk = 1 [(gogoproto.customname) = "GroupPK"];

    // payload is the payload to send
    bytes payload = 2;

    // attachment_cids is a list of attachment cids
    repeated bytes attachment_cids = 3 [(gogoproto.customname) = "AttachmentCIDs"];
  }

  message Reply {
    bytes cid = 1 [(gogoproto.customname) = "CID"];
  }
}

message GroupMetadataEvent {
  // event_context contains context information about the event
  EventContext event_context = 1;

  // metadata contains the newly available metadata
  GroupMetadata metadata = 2;

  // event_clear clear bytes for the event
  bytes event = 3;
}

message GroupMessageEvent {
  // event_context contains context information about the event
  EventContext event_context = 1;

  // headers contains headers of the secure message
  MessageHeaders headers = 2;

  // message contains the secure message payload
  bytes message = 3;
}

message GroupMetadataList {
  message Request {
    // group_pk is the identifier of the group
    bytes group_pk = 1 [(gogoproto.customname) = "GroupPK"];

    // since is the lower ID bound used to filter events
    // if not set, will return events since the beginning
    bytes since_id = 2 [(gogoproto.customname) = "SinceID"];

    // since_now will list only new event to come
    // since_id must not be set
    bool since_now = 3;

    // until is the upper ID bound used to filter events
    // if not set, will subscribe to new events to come
    bytes until_id = 4 [(gogoproto.customname) = "UntilID"];

    // until_now will not list new event to come
    // until_id must not be set
    bool until_now = 5;

    // reverse_order indicates whether the previous events should be returned in
    // reverse chronological order
    bool reverse_order = 6;
  }
}

message GroupMessageList {
  message Request {
    // group_pk is the identifier of the group
    bytes group_pk = 1 [(gogoproto.customname) = "GroupPK"];

    // since is the lower ID bound used to filter events
    // if not set, will return events since the beginning
    bytes since_id = 2 [(gogoproto.customname) = "SinceID"];

    // since_now will list only new event to come
    // since_id must not be set
    bool since_now = 3;

    // until is the upper ID bound used to filter events
    // if not set, will subscribe to new events to come
    bytes until_id = 4 [(gogoproto.customname) = "UntilID"];

    // until_now will not list new event to come
    // until_id must not be set
    bool until_now = 5;

    // reverse_order indicates whether the previous events should be returned in
    // reverse chronological order
    bool reverse_order = 6;
  }
}


message GroupInfo {
  message Request {
    // group_pk is the identifier of the group
    bytes group_pk = 1 [(gogoproto.customname) = "GroupPK"];

    // contact_pk is the identifier of the contact
    bytes contact_pk = 2 [(gogoproto.customname) = "ContactPK"];
  }

  message Reply {
    // group is the group invitation, containing the group pk and its type
    Group group = 1;

    // member_pk is the identifier of the current member in the group
    bytes member_pk = 2 [(gogoproto.customname) = "MemberPK"];

    // device_pk is the identifier of the current device in the group
    bytes device_pk = 3 [(gogoproto.customname) = "DevicePK"];
  }
}

message ActivateGroup {
  message Request {
    // group_pk is the identifier of the group
    bytes group_pk = 1 [(gogoproto.customname) = "GroupPK"];

    // local_only will open the group without enabling network interactions
    // with other members
    bool local_only = 2;
  }

  message Reply {
  }
}

message DeactivateGroup {
  message Request {
    // group_pk is the identifier of the group
    bytes group_pk = 1 [(gogoproto.customname) = "GroupPK"];
  }

  message Reply {
  }
}

message MonitorGroup {
  enum TypeEventMonitor {
    TypeEventMonitorUndefined = 0;
    TypeEventMonitorAdvertiseGroup = 1;
    TypeEventMonitorPeerFound = 2;
    TypeEventMonitorPeerJoin = 3;
    TypeEventMonitorPeerLeave = 4;
  }

  message EventMonitorAdvertiseGroup {
    // local peer id advertised
    string peer_id = 1 [(gogoproto.customname) = "PeerID"];
    // maddrs should describe peer maddrs
    repeated string maddrs = 2;
    // driver_name used to advertise the peer
    string driver_name = 3;
    // event topic
    string topic = 4;
  }

  message EventMonitorPeerFound {
    // peer_id of the peer in this context
    string peer_id = 1 [(gogoproto.customname) = "PeerID"];
    // maddrs of the peer in this context
    repeated string maddrs = 2;
    // driver_name used to found the peer
    string driver_name = 3;
    // event topic
    string topic = 4;
  }

  message EventMonitorPeerJoin {
    // peer_id of the peer in this context
    string peer_id = 1 [(gogoproto.customname) = "PeerID"];
    // maddrs of the peer in this context
    repeated string maddrs = 2;
    // event topic
    string topic = 3;
    // is_self indecitate if the given peer is you
    bool is_self = 4;
  }

  message EventMonitorPeerLeave {
    // peer_id of the peer in this context
    string peer_id = 1 [(gogoproto.customname) = "PeerID"];
    // event topic
    string topic = 3;
    // is_self indecitate if the given peer is you
    bool is_self = 4;
  }

  message EventMonitor {
    TypeEventMonitor type = 1;

    EventMonitorAdvertiseGroup advertise_group = 2;
    EventMonitorPeerFound peer_found = 3;
    EventMonitorPeerJoin peer_join = 4;
    EventMonitorPeerLeave peer_leave = 5;
  }

  message Request {
    // filter_group_pk, if set, will filter event by group PK
    bytes group_pk = 1 [(gogoproto.customname) = "GroupPK"];
  }

  message Reply {
    // monitor event
    EventMonitor event = 1;

    // group_pk is the identifier of the group
    bytes group_pk = 2 [(gogoproto.customname) = "GroupPK"];
  }
}


message DebugListGroups {
  message Request {
  }

  message Reply {
    // group_pk is the public key of the group
    bytes group_pk = 1 [(gogoproto.customname) = "GroupPK"];

    // group_type is the type of the group
    GroupType group_type = 2 [(gogoproto.customname) = "GroupType"];

    // contact_pk is the contact public key if appropriate
    bytes contact_pk = 3 [(gogoproto.customname) = "ContactPK"];
  }
}

message DebugInspectGroupStore {
  message Request {
    // group_pk is the identifier of the group
    bytes group_pk = 1 [(gogoproto.customname) = "GroupPK"];

    // log_type is the log to inspect
    DebugInspectGroupLogType log_type = 2 [(gogoproto.customname) = "LogType"];
  }

  message Reply {
    // cid is the CID of the IPFS log entry
    bytes cid = 1 [(gogoproto.customname) = "CID"];

    // parent_cids is the list of the parent entries
    repeated bytes parent_cids = 2  [(gogoproto.customname) = "ParentCIDs"];

    // event_type metadata event type if subscribed to metadata events
    EventType metadata_event_type = 3;

    // device_pk is the public key of the device signing the entry
    bytes device_pk = 4 [(gogoproto.customname) = "DevicePK"];

    // payload is the un encrypted entry payload if available
    bytes payload = 6;
  }
}

message DebugGroup {
  message Request {
    // group_pk is the identifier of the group
    bytes group_pk = 1 [(gogoproto.customname) = "GroupPK"];
  }

  message Reply {
    // peer_ids is the list of peer ids connected to the same group
    repeated string peer_ids = 1  [(gogoproto.customname) = "PeerIDs"];
  }
}

message AuthExchangeResponse {
  string access_token = 1;
  string scope = 2;
  string error = 3;
  string error_description = 4;
  map<string, string> services = 5;
}

message DebugAuthServiceSetToken {
  message Request {
    AuthExchangeResponse token = 1;
    string authentication_url = 2 [(gogoproto.customname) = "AuthenticationURL"];
  }
  message Reply {}
}

enum DebugInspectGroupLogType {
  DebugInspectGroupLogTypeUndefined = 0;
  DebugInspectGroupLogTypeMessage = 1;
  DebugInspectGroupLogTypeMetadata = 2;

}

enum ContactState {
  ContactStateUndefined = 0;
  ContactStateToRequest = 1;
  ContactStateReceived = 2;
  ContactStateAdded = 3;
  ContactStateRemoved = 4;
  ContactStateDiscarded = 5;
  ContactStateBlocked = 6;
}

message ShareableContact {
  // pk is the account to send a contact request to
  bytes pk = 1 [(gogoproto.customname) = "PK"];

  // public_rendezvous_seed is the rendezvous seed used by the account to send a contact request to
  bytes public_rendezvous_seed = 2;

  // metadata is the metadata specific to the app to identify the contact for the request
  bytes metadata = 3;
}

message ServiceTokenSupportedService {
  string service_type = 1;
  string service_endpoint = 2;
}

message ServiceToken {
  string token = 1;
  string authentication_url = 2  [(gogoproto.customname) = "AuthenticationURL"];
  repeated ServiceTokenSupportedService supported_services = 3;
  int64 expiration = 4;
}

message AuthServiceCompleteFlow {
  message Request{
    string callback_url = 1 [(gogoproto.customname) = "CallbackURL"];
  }
  message Reply{
    string token_id = 1 [(gogoproto.customname) = "TokenID"];
  }
}

message AuthServiceInitFlow {
  message Request {
    string auth_url = 1 [(gogoproto.customname) = "AuthURL"];
  }
  message Reply {
    string url = 1 [(gogoproto.customname) = "URL"];
    bool secure_url = 2 [(gogoproto.customname) = "SecureURL"];
  }
}

message ServicesTokenList {
  message Request{}
  message Reply{
    string token_id = 1 [(gogoproto.customname) = "TokenID"];
    ServiceToken service = 2;
  }
}

message ServicesTokenCode {
  repeated string services = 1;
  string code_challenge = 2;
  string token_id = 3 [(gogoproto.customname) = "TokenID"];
}


message ReplicationServiceRegisterGroup {
  message Request{
    string token_id = 1 [(gogoproto.customname) = "TokenID"];
    bytes group_pk = 2 [(gogoproto.customname) = "GroupPK"];
  }
  message Reply{}
}

message ReplicationServiceReplicateGroup {
  message Request {
    Group group = 1;
  }
  message Reply {
    bool ok = 1 [(gogoproto.customname) = "OK"];
  }
}

message SystemInfo {
  message Request {}
  message Reply {
    Process process = 1;
    P2P p2p = 2 [(gogoproto.customname) = "P2P"];
    OrbitDB orbitdb = 3 [(gogoproto.customname) = "OrbitDB"];
    repeated string warns = 4;
  }

  message OrbitDB {
    ReplicationStatus account_metadata = 1;

    message ReplicationStatus {
      int64 progress = 1;
      int64 maximum = 2;
      int64 buffered = 3;
      int64 queued = 4;
    }
  }

  message P2P {
    int64 connected_peers = 1;
  }
  message Process {
    string version = 1;
    string vcs_ref = 2;
    int64 uptime_ms = 3 [(gogoproto.customname) = "UptimeMS"];
    int64 user_cpu_time_ms = 10 [(gogoproto.customname) = "UserCPUTimeMS"];
    int64 system_cpu_time_ms = 11 [(gogoproto.customname) = "SystemCPUTimeMS"];
    int64 started_at = 12;
    uint64 rlimit_cur = 13;
    int64 num_goroutine = 14;
    int64 nofile = 15;
    bool too_many_open_files = 16;
    int64 num_cpu = 17 [(gogoproto.customname) = "NumCPU"];
    string go_version = 18;
    string operating_system = 19;
    string host_name = 20;
    string arch = 21;
    uint64 rlimit_max = 22;
    int64 pid = 23 [(gogoproto.customname) = "PID"];
    int64 ppid = 24 [(gogoproto.customname) = "PPID"];
    int64 priority = 25;
    int64 uid = 26 [(gogoproto.customname) = "UID"];
    string working_dir = 27;
    string system_username = 28;
  }
}

message PeerList {
  message Request {}
  message Reply {
    repeated Peer peers = 1;
  }

  message Peer {
    // id is the libp2p.PeerID.
    string id = 1 [(gogoproto.customname) = "ID"];

    // routes are the list of active and known maddr.
    repeated Route routes = 2;

    // errors is a list of errors related to the peer.
    repeated string errors = 3;

    // Features is a list of available features.
    repeated Feature features = 4;

    // MinLatency is the minimum latency across all the peer routes.
    int64 min_latency = 5;

    // IsActive is true if at least one of the route is active.
    bool is_active = 6;

    // Direction is the aggregate of all the routes's direction.
    Direction direction = 7;
  }

  message Route {
    // IsActive indicates whether the address is currently used or just known.
    bool is_active = 1;

    // Address is the multiaddress via which we are connected with the peer.
    string address = 2;

    // Direction is which way the connection was established.
    Direction direction = 3;

    // Latency is the last known round trip time to the peer in ms.
    int64 latency = 4;

    // Streams returns list of streams established with the peer.
    repeated Stream streams = 5;
  }

  message Stream {
    // id is an identifier used to write protocol headers in streams.
    string id = 1 [(gogoproto.customname) = "ID"];
  }

  enum Feature {
    UnknownFeature = 0;
    BertyFeature = 1;
    BLEFeature = 2;
    LocalFeature = 3;
    TorFeature = 4;
    QuicFeature = 5;

  }
}

enum Direction {
  UnknownDir = 0;
  InboundDir = 1;
  OutboundDir = 2;
  BiDir = 3;
}

message AttachmentPrepare {
  message Request {
    // block is a plaintext block to append
    bytes block = 1;

    /* Header data:
    ** IMPORTANT: The first request must contain the header data and no block. Header data in following requests will be ignored
    */

    // disable_encryption tells the protocol to store the file as plain text
    bool disable_encryption = 2;
  }

  message Reply {
    // attachment_cid is the cid of the (encrypted) file
    bytes attachment_cid = 1 [(gogoproto.customname) = "AttachmentCID"];
  }
}

message AttachmentRetrieve {
  message Request {
    // attachment_cid is the cid of the (encrypted) file
    bytes attachment_cid = 1 [(gogoproto.customname) = "AttachmentCID"];
  }

  message Reply {
    // block is a plaintext block to append
    bytes block = 2;
  }
}

// Progress define a generic object that can be used to display a progress bar for long-running actions.
message Progress {
  string state = 1;
  string doing = 2;
  float progress = 3;
  uint64 completed = 4;
  uint64 total = 5;
  uint64 delay = 6;
}

message MemberWithDevices {
  bytes member_pk = 1 [(gogoproto.customname) = "MemberPK"];
  repeated bytes devices_pks = 2 [(gogoproto.customname) = "DevicePKs"];
}

message OutOfStoreMessage {
  bytes cid = 1 [(gogoproto.customname) = "CID"];
  bytes device_pk = 2 [(gogoproto.customname) = "DevicePK"];
  fixed64 counter = 3;
  bytes sig = 4;
  fixed32 flags = 5;
  bytes encrypted_payload = 6;
  bytes nonce = 7;
}

message PushServiceReceiver {
  // token_type is the type of the token used, it allows us to act as a proxy to the appropriate push server
  push.v1.PushServiceTokenType token_type = 1;

  // bundle_id is the app identifier
  string bundle_id = 2 [(gogoproto.customname) = "BundleID"];

  // token is the device identifier used
  bytes token = 3;

  // recipient_public_key is the public key which will be used to encrypt the payload
  bytes recipient_public_key = 4;
}

message PushServer {
  bytes server_key = 1;
  string service_addr = 2;
}

message PushDeviceTokenRegistered {
  PushServiceReceiver token = 1;

  // device_pk is the public key of the device sending the message
  bytes device_pk = 2 [(gogoproto.customname) = "DevicePK"];
}

message PushDeviceServerRegistered {
  PushServer server = 1;

  // device_pk is the public key of the device sending the message
  bytes device_pk = 2 [(gogoproto.customname) = "DevicePK"];
}

message PushMemberTokenUpdate {
  PushServer server = 1;

  bytes token = 2;

  // device_pk is the public key of the device sending the message
  bytes device_pk = 3 [(gogoproto.customname) = "DevicePK"];
}

message PushReceive {
  message Request {
    bytes payload = 1;
  }
  message Reply {
    OutOfStoreMessage message = 1;
    bytes cleartext = 2;
    bytes group_public_key = 3;
    bool already_received = 4;
  }
}

message PushSend {
  message Request {
    bytes cid = 1 [(gogoproto.customname) = "CID"];
    bytes group_public_key = 2;
    repeated MemberWithDevices group_members = 3;
  }
  message Reply {
    repeated MemberWithDevices group_members = 1;
  }
}

message PushShareToken {
  message Request {
    bytes group_pk = 1 [(gogoproto.customname) = "GroupPK"];
    PushServer server = 2;
    PushServiceReceiver receiver = 3;
  }
  message Reply {}
}

message PushSetDeviceToken {
  message Request {
    PushServiceReceiver receiver = 1;
  }
  message Reply {}
}

message PushSetServer {
  message Request {
    PushServer server = 1;
  }
  message Reply {}
}

message FirstLastCounters {
  uint64 first = 1;
  uint64 last = 2;
}

// OrbitDBMessageHeads is the payload sent on orbitdb to share peer's heads
message OrbitDBMessageHeads {
  message Box {
    string address = 1;
    bytes heads = 2;
  }

  // sealed box should contain encrypted Box
  bytes sealed_box = 2;

  // current topic used
  bytes raw_rotation = 3;
}
