{{- /* . | prettyjson */ -}}
{{- /* Default content */ -}}
{{- if not (getStore "headerSet") -}}
schema: service.graphql


# Let gqlgen know where to put the generated server
exec:
  filename: graph/generated/generated.go
  package: generated

# Let gqlgen know where to the generated models (if any)
model:
  filename: models/generated.go
  package: models

# Optional, turns on resolver stub generation
resolver:
  filename: resolver.go # where to write them
  type: Resolver  # whats the resolver root implementation type called?

# Tell gqlgen about any existing models you want to reuse for
# graphql. These normally come from the db or a remote api.
models:
{{setStore "headerSet" true}}
{{- end}}

{{- $PackageName := .File.Package | replace "." "_" | camelCase}}
{{- $FilePackageName := .File.Package | replace "." "/" }}
{{- setStore "packageName" $PackageName}}
{{- setStore "filePackageName" $FilePackageName}}
{{- setStore "namespace" "" }}
{{- setStore "goPackage" (splitArray ";" .File.Options.GoPackage | first) }}

{{- /* Associate GraphQL type with internal Go type */ -}}
{{- define "nestedType"}}
    {{- $PackageName := getStore "packageName"}}
    {{- $GoPackage := getStore "goPackage"}}
    {{- $FilePackageName := getStore "filePackageName"}}
    {{- range .}}
        {{- $backup := getStore "namespace"}}
        {{- $name := concat $backup .Name -}}
        {{- setStore "name" $name }}
        {{- if $backup }}
            {{- $name := concat $backup "_" .Name -}}
            {{- setStore "name" $name }}
        {{- end }}

        {{- $name := getStore "name"}}
        {{- setStore "namespace" $name}}
  {{$PackageName}}{{$name}}:
    model: {{$GoPackage}}.{{$name}}
        {{- setStore "namespace" .Name}}
        {{- if .NestedType}}
            {{- template "nestedType" .NestedType}}
        {{- end}}
        {{- setStore "namespace" $backup -}}
    {{- end}}
{{- end}}


{{- /* Top level thingy */ -}}
{{- template "nestedType" .File.MessageType }}
