{{~#if (contains filename "api/node/service.proto")~}}

import { observable } from 'mobx'
import Stream from 'stream'
import objectHash from 'object-hash'
import Mutex from 'await-mutex'

  {{#with (lookup 'berty.node.CommitLog.Entity')}}
    {{#each fields}}
      {{#with resolvedType}}
        export class {{name}}EntityStore {
            _store = null

            constructor (store, data) {
              this._store = store
              Object.keys(data).forEach(key => (this[key] = data[key]))
            }

            {{#each fields}}
              {{#if (and resolvedType (get (case 'camel' type) ../../../fields))}}
                get {{name}} () {
                  {{#if repeated}}
                    const {{name}} = []
                    for (const [, _] of this._store.entity.{{case 'camel' type}}) {
                      if (_.{{case 'camel' ../name}}Id === this.id) {
                        {{name}}.push(_)
                        continue
                      }
                    }
                    return {{name}}
                  {{else}}
                    const {{name}} = this._store.entity.{{case 'camel' type}}.get(this.{{name}}Id)
                    if ({{name}} == null) {
                        this._store.node.service.{{case 'camel' type}}({ id: this.{{name}}Id })
                    }
                    return {{name}}
                  {{/if}}
                }
                set {{name}} (_) {
                  {{#if repeated}}
                    _.forEach(_ => {
                  {{/if}}

                  let entity = this._store.entity.{{case 'camel' type}}.get(_.id)
                  entity = new {{type}}EntityStore(this._store, _)
                  this._store.entity.{{case 'camel' type}}.set(_.id, entity)

                  {{#if repeated}}
                   })
                  {{/if}}
                }
              {{else}}
                {{#if repeated}}
                  {{name}} = []
                {{else}}
                  {{name}} = null
                {{/if}}
              {{/if}}
            {{/each}}
        }
      {{/with}}
    {{/each}}
  {{/with}}

  {{#with (lookup 'berty.node.Service')}}

    export class NodeServiceStore {
      constructor (store, bridge) {
        this._store = store
        this.bridge = bridge
        this.commitLogStream({}).then(commitLog => {
          commitLog.on('data', data => {
            // init the stream
          })
        })
      }

      {{#each methods}}

        {{#if responseStream}}
          {{case 'camel' name}}Cache = {}

          {{#if (not (test name (toRegex 'List$')))}}
           {{case 'camel' name}}Mutex = {}
          {{/if}}
        {{/if}}

        {{case 'camel' name}} = async (input = {}) => {

          {{#if responseStream}}
            {{#if (not (test name (toRegex 'List$')))}}
              const inputHash = objectHash(input)
              const unlock = await (
                this.{{case 'camel' name}}Mutex[inputHash]
                || (this.{{case 'camel' name}}Mutex[inputHash] = new Mutex())
              ).lock()
              if (this.{{case 'camel' name}}Cache[inputHash] == null) {
                this.{{case 'camel' name}}Cache[inputHash] = new Stream.Transform({
            {{else}}
              const transformStream = new Stream.Transform({
            {{/if}}
              writableObjectMode: true,
              readableObjectMode: true,
              transform: (output, encoding, callback) => {
          {{else}}
            let output = await this.bridge.{{case 'camel' name}}(input)
          {{/if}}

          {{#if (is name 'CommitLogStream')}}
            {{#with resolvedResponseType.nested.Entity}}
              Object.keys(output.entity).forEach(
                key => {
                  let _ = output.entity[key]
                  if (_ == null) {
                    return
                  }
                  switch (key) {
                    default:
                      break
                    {{#each fields}}
                      case '{{name}}': {
                        let entity = this._store.entity.{{case 'camel' resolvedType.name}}.get(_.id)
                        switch (output.operation) {
                          default:
                          case 0:
                          case 1:
                            entity = new {{resolvedType.name}}EntityStore(this._store, _)
                            this._store.entity.{{case 'camel' resolvedType.name}}.set(_.id, entity)
                            break
                          case 2:
                            if (entity) {
                              this._store.entity.{{case 'camel' resolvedType.name}}.delete(_.id)
                            }
                            break
                        }
                        _ = entity
                        break
                      }
                    {{/each}}
                  }
                  output.entity[key] = _
                }
              )
            {{/with}}
          {{/if}}

          {{#with (lookup 'berty.node.CommitLog.Entity')}}
            {{#each fields}}
              {{#if (eq resolvedType.name ../../resolvedResponseType.name)}}
                let entity = this._store.entity.{{case 'camel' resolvedType.name}}.get(output.id)
                {{#if (test ../../name (toRegex '(Remove|Delete)$'))}}
                  if (entity) {
                    this._store.entity.{{case 'camel' resolvedType.name}}.delete(output.id)
                  }
                {{else}}
                  entity = new {{resolvedType.name}}EntityStore(this._store, output)
                  this._store.entity.{{case 'camel' resolvedType.name}}.set(output.id, entity)
                {{/if}}
                output = entity
              {{/if}}
            {{/each}}
          {{/with}}

          {{#if responseStream}}
                callback(null, output)
              },
            })
            const stream = await this.bridge.{{case 'camel' name}}(input)

            {{#if (not (test name (toRegex 'List$')))}}
                this.{{case 'camel' name}}Cache[inputHash].setMaxListeners(30)
                stream.pipe(this.{{case 'camel' name}}Cache[inputHash])
                this.{{case 'camel' name}}Cache[inputHash].on('end', () => {
                  delete this.{{case 'camel' name}}Cache[inputHash]
                })
              }
              const passThroughStream = new Stream.PassThrough({
                  writableObjectMode: true,
                  readableObjectMode: true,
                  destroy: () => {
                    this.{{case 'camel' name}}Cache[inputHash].unpipe(passThroughStream)
                    passThroughStream.push(null)
                  },
              })
              this.{{case 'camel' name}}Cache[inputHash].pipe(passThroughStream)
              unlock()
              return passThroughStream
            {{else}}
              stream.pipe(transformStream)
              return transformStream
            {{/if}}
          {{else}}
            return output
          {{/if}}

        }
      {{/each}}
    }
  {{/with}}

  export class Store {
    constructor (bridge) {
      this.bridge = bridge

      this.entity = {
        {{#with (lookup 'berty.node.CommitLog.Entity')}}
          {{#each fields}}
            {{case 'camel' resolvedType.name}}: observable.map({}, { deep: true }),
          {{/each}}
        {{/with}}
      }

      this.node = {
        service: this.bridge && this.bridge.node && this.bridge.node.service && new NodeServiceStore(this, this.bridge.node.service),
      }

      this.daemon = this.bridge.daemon
    }
  }

{{~/if~}}
