// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: server.proto

package server

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ProxyClient is the client API for Proxy service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProxyClient interface {
	TestConnection(ctx context.Context, in *TestConnection_Request, opts ...grpc.CallOption) (*TestConnection_Response, error)
	TestConnectionToPeer(ctx context.Context, in *TestConnectionToPeer_Request, opts ...grpc.CallOption) (*TestConnectionToPeer_Response, error)
	IsProcessRunning(ctx context.Context, in *IsProcessRunning_Request, opts ...grpc.CallOption) (*IsProcessRunning_Response, error)
	ConnectToPeer(ctx context.Context, in *ConnectToPeer_Request, opts ...grpc.CallOption) (*ConnectToPeer_Response, error)
	UploadLogs(ctx context.Context, in *UploadLogs_Request, opts ...grpc.CallOption) (*UploadLogs_Response, error)
	CreateInvite(ctx context.Context, in *CreateInvite_Request, opts ...grpc.CallOption) (*CreateInvite_Response, error)
	JoinGroup(ctx context.Context, in *JoinGroup_Request, opts ...grpc.CallOption) (*JoinGroup_Response, error)
	StartReceiveMessage(ctx context.Context, in *StartReceiveMessage_Request, opts ...grpc.CallOption) (*StartReceiveMessage_Response, error)
	StopReceiveMessage(ctx context.Context, in *StopReceiveMessage_Request, opts ...grpc.CallOption) (*StopReceiveMessage_Response, error)
	AddReplication(ctx context.Context, in *AddReplication_Request, opts ...grpc.CallOption) (*AddReplication_Response, error)
	NewTest(ctx context.Context, in *NewTest_Request, opts ...grpc.CallOption) (*NewTest_Response, error)
	StartTest(ctx context.Context, in *StartTest_Request, opts ...grpc.CallOption) (*StartTest_Response, error)
	StopTest(ctx context.Context, in *StopTest_Request, opts ...grpc.CallOption) (*StopTest_Response, error)
	IsTestRunning(ctx context.Context, in *IsTestRunning_Request, opts ...grpc.CallOption) (*IsTestRunning_Response, error)
	AddReliability(ctx context.Context, in *AddReliability_Request, opts ...grpc.CallOption) (*AddReliability_Response, error)
}

type proxyClient struct {
	cc grpc.ClientConnInterface
}

func NewProxyClient(cc grpc.ClientConnInterface) ProxyClient {
	return &proxyClient{cc}
}

func (c *proxyClient) TestConnection(ctx context.Context, in *TestConnection_Request, opts ...grpc.CallOption) (*TestConnection_Response, error) {
	out := new(TestConnection_Response)
	err := c.cc.Invoke(ctx, "/server.Proxy/TestConnection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proxyClient) TestConnectionToPeer(ctx context.Context, in *TestConnectionToPeer_Request, opts ...grpc.CallOption) (*TestConnectionToPeer_Response, error) {
	out := new(TestConnectionToPeer_Response)
	err := c.cc.Invoke(ctx, "/server.Proxy/TestConnectionToPeer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proxyClient) IsProcessRunning(ctx context.Context, in *IsProcessRunning_Request, opts ...grpc.CallOption) (*IsProcessRunning_Response, error) {
	out := new(IsProcessRunning_Response)
	err := c.cc.Invoke(ctx, "/server.Proxy/IsProcessRunning", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proxyClient) ConnectToPeer(ctx context.Context, in *ConnectToPeer_Request, opts ...grpc.CallOption) (*ConnectToPeer_Response, error) {
	out := new(ConnectToPeer_Response)
	err := c.cc.Invoke(ctx, "/server.Proxy/ConnectToPeer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proxyClient) UploadLogs(ctx context.Context, in *UploadLogs_Request, opts ...grpc.CallOption) (*UploadLogs_Response, error) {
	out := new(UploadLogs_Response)
	err := c.cc.Invoke(ctx, "/server.Proxy/UploadLogs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proxyClient) CreateInvite(ctx context.Context, in *CreateInvite_Request, opts ...grpc.CallOption) (*CreateInvite_Response, error) {
	out := new(CreateInvite_Response)
	err := c.cc.Invoke(ctx, "/server.Proxy/CreateInvite", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proxyClient) JoinGroup(ctx context.Context, in *JoinGroup_Request, opts ...grpc.CallOption) (*JoinGroup_Response, error) {
	out := new(JoinGroup_Response)
	err := c.cc.Invoke(ctx, "/server.Proxy/JoinGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proxyClient) StartReceiveMessage(ctx context.Context, in *StartReceiveMessage_Request, opts ...grpc.CallOption) (*StartReceiveMessage_Response, error) {
	out := new(StartReceiveMessage_Response)
	err := c.cc.Invoke(ctx, "/server.Proxy/StartReceiveMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proxyClient) StopReceiveMessage(ctx context.Context, in *StopReceiveMessage_Request, opts ...grpc.CallOption) (*StopReceiveMessage_Response, error) {
	out := new(StopReceiveMessage_Response)
	err := c.cc.Invoke(ctx, "/server.Proxy/StopReceiveMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proxyClient) AddReplication(ctx context.Context, in *AddReplication_Request, opts ...grpc.CallOption) (*AddReplication_Response, error) {
	out := new(AddReplication_Response)
	err := c.cc.Invoke(ctx, "/server.Proxy/AddReplication", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proxyClient) NewTest(ctx context.Context, in *NewTest_Request, opts ...grpc.CallOption) (*NewTest_Response, error) {
	out := new(NewTest_Response)
	err := c.cc.Invoke(ctx, "/server.Proxy/NewTest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proxyClient) StartTest(ctx context.Context, in *StartTest_Request, opts ...grpc.CallOption) (*StartTest_Response, error) {
	out := new(StartTest_Response)
	err := c.cc.Invoke(ctx, "/server.Proxy/StartTest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proxyClient) StopTest(ctx context.Context, in *StopTest_Request, opts ...grpc.CallOption) (*StopTest_Response, error) {
	out := new(StopTest_Response)
	err := c.cc.Invoke(ctx, "/server.Proxy/StopTest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proxyClient) IsTestRunning(ctx context.Context, in *IsTestRunning_Request, opts ...grpc.CallOption) (*IsTestRunning_Response, error) {
	out := new(IsTestRunning_Response)
	err := c.cc.Invoke(ctx, "/server.Proxy/IsTestRunning", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proxyClient) AddReliability(ctx context.Context, in *AddReliability_Request, opts ...grpc.CallOption) (*AddReliability_Response, error) {
	out := new(AddReliability_Response)
	err := c.cc.Invoke(ctx, "/server.Proxy/AddReliability", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProxyServer is the server API for Proxy service.
// All implementations must embed UnimplementedProxyServer
// for forward compatibility
type ProxyServer interface {
	TestConnection(context.Context, *TestConnection_Request) (*TestConnection_Response, error)
	TestConnectionToPeer(context.Context, *TestConnectionToPeer_Request) (*TestConnectionToPeer_Response, error)
	IsProcessRunning(context.Context, *IsProcessRunning_Request) (*IsProcessRunning_Response, error)
	ConnectToPeer(context.Context, *ConnectToPeer_Request) (*ConnectToPeer_Response, error)
	UploadLogs(context.Context, *UploadLogs_Request) (*UploadLogs_Response, error)
	CreateInvite(context.Context, *CreateInvite_Request) (*CreateInvite_Response, error)
	JoinGroup(context.Context, *JoinGroup_Request) (*JoinGroup_Response, error)
	StartReceiveMessage(context.Context, *StartReceiveMessage_Request) (*StartReceiveMessage_Response, error)
	StopReceiveMessage(context.Context, *StopReceiveMessage_Request) (*StopReceiveMessage_Response, error)
	AddReplication(context.Context, *AddReplication_Request) (*AddReplication_Response, error)
	NewTest(context.Context, *NewTest_Request) (*NewTest_Response, error)
	StartTest(context.Context, *StartTest_Request) (*StartTest_Response, error)
	StopTest(context.Context, *StopTest_Request) (*StopTest_Response, error)
	IsTestRunning(context.Context, *IsTestRunning_Request) (*IsTestRunning_Response, error)
	AddReliability(context.Context, *AddReliability_Request) (*AddReliability_Response, error)
	mustEmbedUnimplementedProxyServer()
}

// UnimplementedProxyServer must be embedded to have forward compatible implementations.
type UnimplementedProxyServer struct {
}

func (UnimplementedProxyServer) TestConnection(context.Context, *TestConnection_Request) (*TestConnection_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestConnection not implemented")
}
func (UnimplementedProxyServer) TestConnectionToPeer(context.Context, *TestConnectionToPeer_Request) (*TestConnectionToPeer_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestConnectionToPeer not implemented")
}
func (UnimplementedProxyServer) IsProcessRunning(context.Context, *IsProcessRunning_Request) (*IsProcessRunning_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsProcessRunning not implemented")
}
func (UnimplementedProxyServer) ConnectToPeer(context.Context, *ConnectToPeer_Request) (*ConnectToPeer_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConnectToPeer not implemented")
}
func (UnimplementedProxyServer) UploadLogs(context.Context, *UploadLogs_Request) (*UploadLogs_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadLogs not implemented")
}
func (UnimplementedProxyServer) CreateInvite(context.Context, *CreateInvite_Request) (*CreateInvite_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateInvite not implemented")
}
func (UnimplementedProxyServer) JoinGroup(context.Context, *JoinGroup_Request) (*JoinGroup_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinGroup not implemented")
}
func (UnimplementedProxyServer) StartReceiveMessage(context.Context, *StartReceiveMessage_Request) (*StartReceiveMessage_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartReceiveMessage not implemented")
}
func (UnimplementedProxyServer) StopReceiveMessage(context.Context, *StopReceiveMessage_Request) (*StopReceiveMessage_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopReceiveMessage not implemented")
}
func (UnimplementedProxyServer) AddReplication(context.Context, *AddReplication_Request) (*AddReplication_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddReplication not implemented")
}
func (UnimplementedProxyServer) NewTest(context.Context, *NewTest_Request) (*NewTest_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewTest not implemented")
}
func (UnimplementedProxyServer) StartTest(context.Context, *StartTest_Request) (*StartTest_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartTest not implemented")
}
func (UnimplementedProxyServer) StopTest(context.Context, *StopTest_Request) (*StopTest_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopTest not implemented")
}
func (UnimplementedProxyServer) IsTestRunning(context.Context, *IsTestRunning_Request) (*IsTestRunning_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsTestRunning not implemented")
}
func (UnimplementedProxyServer) AddReliability(context.Context, *AddReliability_Request) (*AddReliability_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddReliability not implemented")
}
func (UnimplementedProxyServer) mustEmbedUnimplementedProxyServer() {}

// UnsafeProxyServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProxyServer will
// result in compilation errors.
type UnsafeProxyServer interface {
	mustEmbedUnimplementedProxyServer()
}

func RegisterProxyServer(s grpc.ServiceRegistrar, srv ProxyServer) {
	s.RegisterService(&Proxy_ServiceDesc, srv)
}

func _Proxy_TestConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestConnection_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).TestConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.Proxy/TestConnection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).TestConnection(ctx, req.(*TestConnection_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proxy_TestConnectionToPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestConnectionToPeer_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).TestConnectionToPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.Proxy/TestConnectionToPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).TestConnectionToPeer(ctx, req.(*TestConnectionToPeer_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proxy_IsProcessRunning_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsProcessRunning_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).IsProcessRunning(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.Proxy/IsProcessRunning",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).IsProcessRunning(ctx, req.(*IsProcessRunning_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proxy_ConnectToPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectToPeer_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).ConnectToPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.Proxy/ConnectToPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).ConnectToPeer(ctx, req.(*ConnectToPeer_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proxy_UploadLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadLogs_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).UploadLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.Proxy/UploadLogs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).UploadLogs(ctx, req.(*UploadLogs_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proxy_CreateInvite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateInvite_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).CreateInvite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.Proxy/CreateInvite",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).CreateInvite(ctx, req.(*CreateInvite_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proxy_JoinGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinGroup_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).JoinGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.Proxy/JoinGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).JoinGroup(ctx, req.(*JoinGroup_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proxy_StartReceiveMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartReceiveMessage_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).StartReceiveMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.Proxy/StartReceiveMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).StartReceiveMessage(ctx, req.(*StartReceiveMessage_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proxy_StopReceiveMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopReceiveMessage_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).StopReceiveMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.Proxy/StopReceiveMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).StopReceiveMessage(ctx, req.(*StopReceiveMessage_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proxy_AddReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddReplication_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).AddReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.Proxy/AddReplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).AddReplication(ctx, req.(*AddReplication_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proxy_NewTest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewTest_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).NewTest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.Proxy/NewTest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).NewTest(ctx, req.(*NewTest_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proxy_StartTest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartTest_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).StartTest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.Proxy/StartTest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).StartTest(ctx, req.(*StartTest_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proxy_StopTest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopTest_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).StopTest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.Proxy/StopTest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).StopTest(ctx, req.(*StopTest_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proxy_IsTestRunning_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsTestRunning_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).IsTestRunning(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.Proxy/IsTestRunning",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).IsTestRunning(ctx, req.(*IsTestRunning_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proxy_AddReliability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddReliability_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).AddReliability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.Proxy/AddReliability",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).AddReliability(ctx, req.(*AddReliability_Request))
	}
	return interceptor(ctx, in, info, handler)
}

// Proxy_ServiceDesc is the grpc.ServiceDesc for Proxy service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Proxy_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "server.Proxy",
	HandlerType: (*ProxyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TestConnection",
			Handler:    _Proxy_TestConnection_Handler,
		},
		{
			MethodName: "TestConnectionToPeer",
			Handler:    _Proxy_TestConnectionToPeer_Handler,
		},
		{
			MethodName: "IsProcessRunning",
			Handler:    _Proxy_IsProcessRunning_Handler,
		},
		{
			MethodName: "ConnectToPeer",
			Handler:    _Proxy_ConnectToPeer_Handler,
		},
		{
			MethodName: "UploadLogs",
			Handler:    _Proxy_UploadLogs_Handler,
		},
		{
			MethodName: "CreateInvite",
			Handler:    _Proxy_CreateInvite_Handler,
		},
		{
			MethodName: "JoinGroup",
			Handler:    _Proxy_JoinGroup_Handler,
		},
		{
			MethodName: "StartReceiveMessage",
			Handler:    _Proxy_StartReceiveMessage_Handler,
		},
		{
			MethodName: "StopReceiveMessage",
			Handler:    _Proxy_StopReceiveMessage_Handler,
		},
		{
			MethodName: "AddReplication",
			Handler:    _Proxy_AddReplication_Handler,
		},
		{
			MethodName: "NewTest",
			Handler:    _Proxy_NewTest_Handler,
		},
		{
			MethodName: "StartTest",
			Handler:    _Proxy_StartTest_Handler,
		},
		{
			MethodName: "StopTest",
			Handler:    _Proxy_StopTest_Handler,
		},
		{
			MethodName: "IsTestRunning",
			Handler:    _Proxy_IsTestRunning_Handler,
		},
		{
			MethodName: "AddReliability",
			Handler:    _Proxy_AddReliability_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "server.proto",
}
